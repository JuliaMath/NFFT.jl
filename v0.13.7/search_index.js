var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Tobias Knopp and contributors\"\nCurrentModule = NFFT","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of the NFFT.jl package family:","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractNFFTs.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs]","category":"page"},{"location":"api/","page":"API","title":"API","text":"NFFT.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFT]","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = NFFTTools","category":"page"},{"location":"api/","page":"API","title":"API","text":"NFFTTools.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFTTools]","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = NFFT","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AbstractNFFTs, NFFT]","category":"page"},{"location":"api/#AbstractNFFTs.AbstractComplexFTPlan","page":"API","title":"AbstractNFFTs.AbstractComplexFTPlan","text":"AbstractComplexFTPlan{T,D,R}\n\nAbstract type for either an NFFT plan or an NNFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractFTPlan","page":"API","title":"AbstractNFFTs.AbstractFTPlan","text":"AbstractFTPlan{T,D,R}\n\nAbstract type for any NFFT-like plan (NFFT, NFFT, NFCT, NFST).\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNFCTPlan","page":"API","title":"AbstractNFFTs.AbstractNFCTPlan","text":"AbstractNFCTPlan{T,D,R}\n\nAbstract type for an NFCT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNFFTPlan","text":"AbstractNFFTPlan{T,D,R}\n\nAbstract type for an NFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNFSTPlan","page":"API","title":"AbstractNFFTs.AbstractNFSTPlan","text":"AbstractNFSTPlan{T,D,R}\n\nAbstract type for an NFST plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNNFFTPlan","text":"AbstractNNFFTPlan{T,D,R}\n\nAbstract type for an NNFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractRealFTPlan","page":"API","title":"AbstractNFFTs.AbstractRealFTPlan","text":"AbstractRealFTPlan{T,D,R}\n\nAbstract type for either an NFCT plan or an NFST plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.accuracyParams-Tuple{}","page":"API","title":"AbstractNFFTs.accuracyParams","text":"accuracyParams(; [m, σ, reltol]) -> m, σ, reltol\n\nCalculate accuracy parameters m, σ, reltol based on either\n\nreltol\n\nor\n\nm, σ\n\nTODO: Right now, the oversampling parameter is not taken into account, i.e. σ=2.0 is assumed\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfct-Tuple{Any, AbstractArray}","page":"API","title":"AbstractNFFTs.nfct","text":"nfft(k, f, rest...; kwargs...)\n\ncalculates the nfft of the array f for the nodes contained in the matrix k The output is a vector of length M=size(nodes,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfct_transpose-Tuple{Any, Any, Any}","page":"API","title":"AbstractNFFTs.nfct_transpose","text":"nfft_adjoint(k, N, fHat, rest...; kwargs...)\n\ncalculates the adjoint nfft of the vector fHat for the nodes contained in the matrix k. The output is an array of size N\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft-Tuple{Any, AbstractArray}","page":"API","title":"AbstractNFFTs.nfft","text":"nfft(k, f, rest...; kwargs...)\n\ncalculates the nfft of the array f for the nodes contained in the matrix k The output is a vector of length M=size(nodes,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfft_adjoint-Tuple{Any, Any, Any}","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"nfft_adjoint(k, N, fHat, rest...; kwargs...)\n\ncalculates the adjoint nfft of the vector fHat for the nodes contained in the matrix k. The output is an array of size N\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfst-Tuple{Any, AbstractArray}","page":"API","title":"AbstractNFFTs.nfst","text":"nfft(k, f, rest...; kwargs...)\n\ncalculates the nfft of the array f for the nodes contained in the matrix k The output is a vector of length M=size(nodes,2)\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfst_transpose-Tuple{Any, Any, Any}","page":"API","title":"AbstractNFFTs.nfst_transpose","text":"nfft_adjoint(k, N, fHat, rest...; kwargs...)\n\ncalculates the adjoint nfft of the vector fHat for the nodes contained in the matrix k. The output is an array of size N\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T","page":"API","title":"AbstractNFFTs.nodes!","text":"nodes!(p, k) -> p\n\nChange nodes k in the plan p operation and return the plan.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_in","text":"size_in(p)\n\nSize of the input array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has R entries.  Note that this will be the output size for the transposed / adjoint operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_out","text":"size_out(p)\n\nSize of the output array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has R entries.  Note that this will be the input size for the transposed / adjoint operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractComplexFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}","page":"API","title":"Base.:*","text":"    *(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFFT/NNFFT of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractRealFTPlan{T}, AbstractArray{U, D}}} where {T, U, D}","page":"API","title":"Base.:*","text":"    *(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFCT/NFST of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractFTPlan{T}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(fHat, p, f) -> fHat\n\nInplace NFFT/NFCT/NFST/NNFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, <:AbstractComplexFTPlan{T}}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(f, p, fHat) -> f\n\nInplace adjoint NFFT/NNFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Transpose{T, <:AbstractRealFTPlan{T}}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(f, p, fHat) -> f\n\nInplace transposed NFCT/NFST transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{<:Array}, Matrix{T}, NTuple{D, Int64}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.plan_nfft","text":"    plan_nfft(k::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)\n\ncompute a plan for the NFFT of a size-N array at the nodes contained in k.\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.precomputeLinInterp-NTuple{5, Any}","page":"API","title":"NFFT.precomputeLinInterp","text":"Precompute the look up table for the window function φ.\n\nRemarks:\n\nOnly the positive half is computed\nThe window is computed for the interval [0, (m)/Ñ]. The reason for the +2 is that we do evaluate the window function outside its interval, since x does not necessary match the sampling points\nThe window has K+1 entries and during the index calculation we multiply with the factor K/(m).\nIt is very important that K/(m) is an integer since our index calculation exploits this fact. We therefore always use Int(K/(m))instead of K÷(m) since this gives an error while the later variant would silently error.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = NFFTTools","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NFFTTools]","category":"page"},{"location":"api/#NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T","page":"API","title":"NFFTTools.calculateToeplitzKernel!","text":"calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in f, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel f has to be Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiecy, call this function with Float32.(tr), and set the type of f accordingly.\n\nRequired Arguments\n\nf::Array{T}: Array in which the kernel will be written.\np::AbstractNFFTPlan: NFFTPlan with the same dimensions as tr, which will be overwritten in place.\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\nfftplan: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\n\nExamples\n\njulia> using FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> p = plan_nfft(trj, (2Nx,2Nx))\nNFFTPlan with 1000 sampling points for an input array of size(64, 64) and an output array of size(1000,) with dims 1:2\n\njulia> fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);\n\njulia> λ = Array{ComplexF32}(undef, 2Nx, 2Nx);\n\njulia> calculateToeplitzKernel!(λ, p, trj, fftplan);\n\njulia> y = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(y, λ);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T","page":"API","title":"NFFTTools.calculateToeplitzKernel","text":"calculateToeplitzKernel(shape, tr::Matrix{T}[; m = 4, σ = 2.0, window = :kaiser_bessel, fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of shape, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel is Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiency, call this function with Float32.(tr), and the kernel will also be Float32.\n\nRequired Arguments\n\nshape::NTuple(Int): size of the image; e.g. (256, 256) for 2D imaging, or (256,256,128) for 3D imaging\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\n\nOptional Arguments:\n\nm::Int: nfft kernel size (used to calculate the Toeplitz kernel); default = 4\nσ::Number: nfft oversampling factor during the calculation of the Toeplitz kernel; default = 2\n\nKeyword Arguments:\n\nfftplan: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE). If this constructor is used many times, it is worth to precompute the plan with plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE) and reuse it.\nkwargs: Passed on to plan_fft! via NFFTPlan; can be used to modify the flags flags=FFTW.ESTIMATE, timelimit=Inf.\n\nExamples\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj)\n64×64 Matrix{ComplexF32}:\n -432.209+297.833im    271.68-526.348im  …   3044.35+34.6322im\n  990.057-244.569im  -582.825+473.084im      45.7631-87.8965im\n  1922.01+223.525im   9248.63-452.04im       3649.78+108.941im\n -402.371-3.37619im   496.815+231.891im      322.646-329.089im\n -482.346-121.534im   559.756-106.981im      155.183+454.0im\n   3293.8+194.388im  -3361.43+34.1272im  …   2672.16-526.853im\n -936.331+172.246im   4394.11-400.762im     -1121.04+160.219im\n -135.828+169.448im   3509.17+59.0678im      3883.84-501.913im\n  395.143+158.638im   24.4377-387.153im       5731.3+173.827im\n  925.902-117.765im    2935.3+346.28im      -1414.12-214.701im\n         ⋮                               ⋱\n  2239.72-295.883im   490.442+524.399im  …   2028.84-36.5824im\n -1108.11+227.146im   24.7403-455.661im     -549.699+105.319im\n  1323.78+110.713im  -321.052+117.802im      651.944-443.178im\n -52.1597+288.0im    -326.042-516.516im       3619.1+44.4651im\n  1180.56+73.3666im  -26.1233+155.148im     -869.065-405.832im\n  3555.36+649.527im  -198.245-878.042im  …   1198.83-317.062im\n -368.958-177.954im  -360.343+406.469im     -1478.96-154.512im\n  4861.29+38.9623im   6082.55-267.478im      2519.09+293.503im\n  1022.55-185.869im   177.426+414.384im      3650.56-146.597im\n\njulia> y = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(y, λ)\n32×32 Matrix{ComplexF32}:\n  177.717-52.0493im   10.6059+20.7185im  …   746.131+330.005im\n -311.858+988.219im  -1216.83-1295.14im      410.732+751.925im\n -1082.27+872.968im   1023.97-1556.45im     -923.699+478.63im\n -999.035-525.161im  -1694.59-658.558im     -521.044+607.005im\n -342.999+1481.82im  -1729.18-2712.81im      56.5212+1394.81im\n -1187.65-1979.55im   1389.67+970.033im  …   2968.93-744.264im\n -666.533+485.511im  -1315.83+409.855im     -610.146+132.258im\n  1159.57+64.6059im  -299.169-569.622im      663.802+396.827im\n -795.112-1464.63im   -462.43+2442.77im     -1622.72+1701.27im\n -1047.67+31.5578im  -1127.65-936.043im      474.071+797.911im\n         ⋮                               ⋱\n  327.345+2191.71im  -904.635+558.786im     -1449.32-276.721im\n  -1047.2-71.362im    363.109+567.346im      -1974.0-2348.36im\n -1540.45+1661.77im   1175.75+1279.75im  …   1110.61+653.234im\n -526.832-435.297im  -265.021-2019.08im      68.5607-323.086im\n -1076.52-2719.16im  -477.005+2232.06im      -155.59-1275.66im\n  1143.76-735.966im  -380.489+2485.78im      1812.17-261.191im\n  1685.44-1243.29im   1911.16-1157.72im     -991.639-42.8214im\n  1054.11-1282.41im   66.9358-588.991im  …  -952.238+1026.35im\n -417.276-273.367im  -946.698+1971.77im     -890.339-882.05im\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Vararg{Any, 4}}} where {T, N}","page":"API","title":"NFFTTools.convolveToeplitzKernel!","text":"convolveToeplitzKernel!(y::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])\n\nConvolves the image y with the Toeplitz kernel λ and overwrites y with the result. y is also returned for convenience. As this function is commonly applied many times, it is highly recommended to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.\n\nRequired Arguments\n\ny::Array{T,N}: Input image that will be overwritten with the result. y is a matrix (N=2) for 2D imaging and a 3D tensor (N=3) for 3D imaging. The type of the elements T must match the ones of λ.\nλ::Array{T,N}: Toeplitz kernel, which as to be the same type as k, but twice the size due to the required oversampling (cf. calculateToeplitzKernel).\n\nOptional, but highly recommended Arguments\n\nfftplan: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nifftplan: plan for the oversampled inverse FFT. Calculate, e.g., with ifftplan = plan_ifft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nxOS1: pre-allocated array of the size of λ. Pre-allocate with xOS1 = similar(λ).\nxOS2: pre-allocated array of the size of λ. Pre-allocate with xOS2 = similar(λ).\n\nExamples\n\njulia> using FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj);\n\njulia> xOS1 = similar(λ);\n\njulia> xOS2 = similar(λ);\n\njulia> fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);\n\njulia> ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);\n\njulia> y = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(y, λ, fftplan, ifftplan, xOS1, xOS2)\n32×32 Matrix{ComplexF32}:\n  177.717-52.0493im   10.6059+20.7185im  …   746.131+330.005im\n -311.858+988.219im  -1216.83-1295.14im      410.732+751.925im\n -1082.27+872.968im   1023.97-1556.45im     -923.699+478.63im\n -999.035-525.161im  -1694.59-658.558im     -521.044+607.005im\n -342.999+1481.82im  -1729.18-2712.81im      56.5212+1394.81im\n -1187.65-1979.55im   1389.67+970.033im  …   2968.93-744.264im\n -666.533+485.511im  -1315.83+409.855im     -610.146+132.258im\n  1159.57+64.6059im  -299.169-569.622im      663.802+396.827im\n -795.112-1464.63im   -462.43+2442.77im     -1622.72+1701.27im\n -1047.67+31.5578im  -1127.65-936.043im      474.071+797.911im\n         ⋮                               ⋱\n  327.345+2191.71im  -904.635+558.786im     -1449.32-276.721im\n  -1047.2-71.362im    363.109+567.346im      -1974.0-2348.36im\n -1540.45+1661.77im   1175.75+1279.75im  …   1110.61+653.234im\n -526.832-435.297im  -265.021-2019.08im      68.5607-323.086im\n -1076.52-2719.16im  -477.005+2232.06im      -155.59-1275.66im\n  1143.76-735.966im  -380.489+2485.78im      1812.17-261.191im\n  1685.44-1243.29im   1911.16-1157.72im     -991.639-42.8214im\n  1054.11-1282.41im   66.9358-588.991im  …  -952.238+1026.35im\n -417.276-273.367im  -946.698+1971.77im     -890.339-882.05im\n\n\n\n\n\n\n","category":"method"},{"location":"performance/#Accuracy-and-Performance","page":"Performance","title":"Accuracy and Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"On this page, the accuracy and the performance of NFFT.jl are investigated. For comparison we use the C library NFFT3 and the C++ library FINUFFT.  The parameters for the benchmark are ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"bmN_text1D=(512*512) bmN_text2D=(512512) bmN_text3D=(646464)\nJ= vert bmN vert\nm=3 dots 8\nsigma = 2\nPOLYNOMIAL and TENSOR precomputation\n1 thread\nrandom nodes","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"All benchmarks are performed with @belapsed from BenchmarkTools.jl which takes the minimum of several runs (120 s upper benchmark time). The benchmark is run on a computer with 2 AMD EPYC 7702 CPUs running at 2.0 GHz (256 cores in total) and a main memory of 1024 GB. The benchmark suite is described here.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The results for D=1dots3 are shown in the following graphic illustrating the accuracy (x-axis) versus the performance (y-axis) for various m. ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"(Image: Performance vs Accurracy 1D)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"The results show that NFFT.jl is one of the fastest NFFT libraries. One can chose between shorter precomputation time using POLYNOMIAL precomputation or faster transforms using TENSOR precomputation.","category":"page"},{"location":"abstract/#Abstract-Interface-for-NFFTs","page":"AbstractNFFTs","title":"Abstract Interface for NFFTs","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The package AbstractNFFTs provides the abstract interface for NFFT implementations. Defining an abstract interface has the advantage that different implementations can be used and exchanging requires  only small effort.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"An overview about the current packages and their dependencies is shown in the following package tree:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"(Image: NFFT.jl package family structure)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"note: Note\nIf you are not an expert user, you likely do not require different NFFT implementations and we therefore recommend to just use NFFT.jl and not worry about the abstract interface. ","category":"page"},{"location":"abstract/#Implementations","page":"AbstractNFFTs","title":"Implementations","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Currently, there are four implementations of the AbstractNFFTs interface:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"NFFT.jl: This is the reference implementation running und the CPU.\nCuNFFT.jl: An implementation running on graphics hardware of Nvidia exploiting CUDA.jl\nNFFT3.jl: In the Wrapper directory of NFFT.jl there is a wrapper around the NFFT3.jl package following the  AbstractNFFTs interface. NFFT3.jl is itself a wrapper around the high performance C library NFFT3.\nFINUFFT.jl: In the Wrapper directory of NFFT.jl there is a wrapper around the FINUFFT.jl package. FINUFFT.jl is itself a wrapper around the high performance C++ library FINUFFT.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"note: Note\nRight now one needs to install NFFT.jl and manually include the wrapper files. In the future we hope to integrate the wrappers in NFFT3.jl and FINUFFT.jl directly such that it is much more convenient to switch libraries.","category":"page"},{"location":"abstract/#Interface","page":"AbstractNFFTs","title":"Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"An NFFT implementation needs to define a new type that is a subtype of AbstractNFFTPlan{T,D,R}. Here","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"T is the real-valued element type of the nodes, i.e. a transform operating on Complex{Float64} values and Float64 nodes uses the type T=Float64.\nD is the size of the input vector\nR is the size of the output vector. Usually this will be R=1 unless a directional NFFT is implemented.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"For instance the CuNFFTPlan is defined like this","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"mutable struct CuNFFTPlan{T,D} <: AbstractNFFTPlan{T,D,1} \n  ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"In addition to the plan, the following functions need to be implemented: ","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"size_out(p)\nsize_out(p)\nmul!(fHat, p, f) -> fHat\nmul!(f, p::Adjoint{Complex{T},<:AbstractNFFTPlan{T}}, fHat) -> f\nnodes!(p, k) -> p","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"All these functions are exported from AbstractNFFTs and we recommend to implement them using the explicit AbstractNFFTs. prefix:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"function AbstractNFFTs.size_out(p:MyNFFTPlan)\n ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"We next outline all of the aforementioned functions and describe their behavior:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    size_in(p)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Size of the input array for an NFFT operation. The returned tuple has D entries.  Note that this will be the output array for an adjoint NFFT.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    size_out(p)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Size of the output array for an NFFT operation. The returned tuple has R entries.  Note that this will be the input array for an adjoint NFFT.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    mul!(fHat, p, f) -> fHat","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Inplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    mul!(f, p::Adjoint{Complex{T},<:AbstractNFFTPlan{T}}, fHat) -> f","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Inplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"    nodes!(p, k)","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Exchange the nodes k in the plan p and return the plan. The implementation of this function is optional.","category":"page"},{"location":"abstract/#Plan-Interface","page":"AbstractNFFTs","title":"Plan Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The constructor for a plan also has a defined interface. It should be implemented in this way:","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"function MyNFFTPlan(k::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {T,D}\n  ...\nend","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"All parameters are put into keyword arguments that have to match as well. We describe the keyword arguments in more detail in the overview page. Using the same plan interface allows to load several NFFT libraries simultaneously and exchange the constructor dynamically by storing the constructor in a function object. This is how the unit tests of NFFT.jl run.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Additionally, to the type-specific constructor one can provide the factory","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"plan_nfft(Q::Type, k::Matrix{T}, N::NTuple{D,Int}; kargs...) where {D}","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"where Q is the Array type, e.g. Array. The reason to require the array type is, that this allows for GPU implementations, which would use for instance CuArray here.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"The package AbstractNFFTs provides a convenient constructor","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"plan_nfft(k::Matrix{T}, N::NTuple{D,Int}; kargs...) where {D}","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"defaulting to the Array type.","category":"page"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"note: Note\nDifferent packages implementing plan_nfft will conflict if the same Q is implemented. In case of NFFT.jl and CuNFFT.jl there is no conflict since the array type is different.","category":"page"},{"location":"abstract/#Derived-Interface","page":"AbstractNFFTs","title":"Derived Interface","text":"","category":"section"},{"location":"abstract/","page":"AbstractNFFTs","title":"AbstractNFFTs","text":"Based on the core low-level interface that an AbstractNFFTPlan needs to provide, the package AbstractNFFT.jl also provides high-level functions like *, nfft, and nfft_adjoint, which internally use the low-level interface. Thus, the implementation of high-level function is shared among all AbstractNFFT.jl implementations.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Basic usage of NFFT.jl is shown in the following example for 1D:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using NFFT\n\nJ, N = 8, 16\nk = range(-0.4, stop=0.4, length=J)  # nodes at which the NFFT is evaluated\nf = randn(ComplexF64, J)             # data to be transformed\np = plan_nfft(k, N, reltol=1e-9)     # create plan\nfHat = adjoint(p) * f                # calculate adjoint NFFT\ny = p * fHat                         # calculate forward NFFT","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the same way the 2D NFFT can be applied:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"J, N = 16, 32\nk = rand(2, J) .- 0.5\nf = randn(ComplexF64, J)\np = plan_nfft(k, (N,N), reltol=1e-9)\nfHat = adjoint(p) * f\ny = p * fHat","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Currently, the eltype of the arguments f and fHat must be compatible with that of the sampling nodes k used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, one can create the plan like this:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"k = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(k, N)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The plan will then internally use Float32 types. The signals f and fHat then need to have the eltype Complex{Float32} or equivalently ComplexF32. Otherwise there will be error messages.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the previous example, the output vector was allocated within the * method. To avoid this allocation one can use the interface","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"mul!(fHat, p, f)\nmul!(y, adjoint(p), fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"which allows to pass the output vector as the first argument.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"One can also perform NFFT computations directly without first creating a plan:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"fHat = nfft(k, f)\ny = nfft_adjoint(k, N, fHat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same sampling nodes k.  Note that nfft_adjoint requires the extra argument N since this cannot be derived from the input vector as can be done for nfft. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"note: Note\nThe constructor plan_nfft is meant to be a generic factory function that can be implemented in different packages. If you want to use a concrete constructor of NFFT.jl use NFFTPlan instead. ","category":"page"},{"location":"overview/#Parameters","page":"Overview","title":"Parameters","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The NFFT has the several parameters that can be passed as a keyword argument to the constructor or the nfft and the nfft_adjoint function.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Parameter Description Example Values\nreltol Relative tolerance that the NFFT achieves. reltol =10^-9\nm Kernel size parameter. The convolution matrix has 2m+1 non-zero entries around each sampling node in each dimension. m in 2dots8\nσ Oversampling factor. The inner FFT is of size σN σ in 125 20\nwindow Convolution window hatvarphi :kaiser_bessel\nprecompute Flag indicating the precomputation strategy for the convolution matrix TENSOR\nblocking Flag block partitioning should be used to speed up computation true\nsortNodes Flag if the nodes should be sorted in a lexicographic way false\nstoreDeconvolutionIdx Flag if the deconvolve indices should be stored. Currently this option is necessary on the GPU true\nfftflags flags passed to the inner AbstractFFT as flags. This can for instance be FFTW.MEASURE in order to optimize the inner FFT FFTW.ESTIMATE","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In practice the default values are properly chosen and there is in most cases no need to change them.  The only parameter you sometimes need to care about are the accuracy parameters reltol, m,\\sigma and the fftflags.","category":"page"},{"location":"overview/#Accuracy","page":"Overview","title":"Accuracy","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"On a high-level it is possible to set the accuracy using the parameter reltol. It will automatically set the low-level parameters m and \\sigma. You only need to change the later if you run into memory issues. It is important that you change only reltol or the pair m,\\sigma.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The relation between reltol, m, and σ depends on the window function and the NFFT implementation. We use the formula","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"w = 2m + 1 = leftlceil textlog_10 frac1textreltol rightrceil + 1","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"which was verified for σ and the default window function. If you change the window function, you should use the parameter m, and σ instead of reltol.","category":"page"},{"location":"overview/#Window-Functions","page":"Overview","title":"Window Functions","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"It is possible to change the internal window function hatvarphi. Available are ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":":gauss\n:spline\n:kaiser_bessel_rev\n:kaiser_bessel \n:cosh_type","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"and one can easily add more by extending the windowFunctions.jl file in Github.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"However, the possibility of changing the window function is only important for NFFT researcher and not for NFFT users. Right now :kaiser_bessel provides the best accuracy and thus there is no reason to change the parameter window to something different.","category":"page"},{"location":"overview/#Precomputation","page":"Overview","title":"Precomputation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are different precomputation strategies available:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Value Description\nNFFT.POLYNOMIAL This option approximates the window function by a polynomial with high degree and evaluates the polynomial during the actual convolution.\nNFFT.LINEAR This option uses a look-up table to first sample the window function and later use linear interpolation during the actual convolution.\nNFFT.FULL This option precomputes the entire convolution matrix and stores it as a SparseMatrixCSC. This option requires more memory and the longest precomputation time. This allows simple GPU implementations like realized in CuNFFT.\nNFFT.TENSOR This option calculates the window on demand but exploits the tensor product structure for multi-dimensional plans.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Again you don't need to change this parameter since the default NFFT.POLYNOMIAL is a good choice in most situations. You may want to use NFFT.TENSOR if you are applying the same transform multiple times since it is a little bit faster than NFFT.POLYNOMIAL but has a higher pre-computation time.","category":"page"},{"location":"overview/#Block-Partitioning","page":"Overview","title":"Block Partitioning","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Internally NFFT can use block partitioning to speedup computation. It helps in two ways","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"It helps improving the memory efficiency by grouping sampling points together which allows for better use of CPU caches.\nBlock partitioning is a mandatory to enable multi-threading in the adjoint NFFT, which would otherwise not be possible because of a data dependency.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We enable block partitioning by default since it helps also in the single-threaded case and thus, there usually is no reason to switch it off.","category":"page"},{"location":"overview/#Multi-Threading","page":"Overview","title":"Multi-Threading","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Most parts of NFFT are multi-threaded when running on the CPU. To this end, start Julia with the option","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia -t T","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"where T it the number of desired threads. NFFT.jl will use all threads that are specified. ","category":"page"},{"location":"overview/#Directional","page":"Overview","title":"Directional","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"J = 11\n\ny = rand(J) .- 0.5\nN = (16,20)\np1 = plan_nfft(y, N, dims=1)\nf = randn(ComplexF64, N)\nfHat = p1 * f","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"p2 = plan_nfft(y, N, dims=2)\nfHat = p2 * f","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now size(fHat) = (16,11).","category":"page"},{"location":"background/#Mathematical-Background","page":"Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"On this page we give a brief overview of the mathematical background of the NFFT. For a full background including a derivation of the NFFT we refer to the NFFT.jl paper.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nIn the literature the NFFT has different names. Often it is called NUFFT, and in the MRI context gridding.","category":"page"},{"location":"background/#NDFT","page":"Background","title":"NDFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"We first define the non-equidistant discrete Fourier transform (NDFT) that corresponds to the ordinary DFT. Let bmN in mathbbN^D with D in mathbbN be the size of the D-dimensional  equidistantly sampled signal bmf = (f_bmn)_bmn in I_bmN. bmf can for instance be a time or spatial domain signal. The signal is indexed using the multi-index set","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"I_bmN = mathbbZ^D cap prod_d=1^D left-fracN_d2fracN_d2right)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and thus represents a regular sampling that would also be considered when applying an ordinary DFT. The NDFT now maps from the equidistant domain to the non-equidistant domain and is defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \thatf_j = sum_ bmn in I_bmN f_bmn  mathrme^-2pimathrmibmncdotbmk_j quad j=1dots J qquad textit(equidistant to non-equidistant)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where the bmk_j in mathbbT^D j=1dots J with J in mathbbN are the nonequidistant sampling nodes, mathbbT = 1212) is the torus and hatbmf is the D-dimensional frequency domain signal.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The direct NDFT has an associated adjoint that can be formulated as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"\ty_bmn = sum_j = 1^J hatf_j  mathrme^2 pi mathrmi  bmn cdot bmk_j bmn in I_bmN qquad textit(non-equidistant to equidistant)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"We note that in general the adjoint NDFT is not the inverse NDFT. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe indices in the index set I_bmN are centered around zero, which is the common definition of the NDFT. In contrast the indices of the DFT usually run from 0dotsN_d-1. This means that an fftshift needs to be applied to change from one representation to the other.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nInstead of the direct/adjoint NDFT terminology, there is an alternative classification that consists of three types. Type 1 corresponds to the adjoint NDFT, type 2 corresponds to the direct NDFT and type 3 corresponds to the NNDFT which has non-equidistant samples in both domains. Further information on this alternative formulation can be found here. ","category":"page"},{"location":"background/#Matrix-Vector-Notation","page":"Background","title":"Matrix-Vector Notation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NDFT can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hatbmf = bmA bmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginaligned\n hatbmf = left( hatf_j right)_j=1^J in mathbbC^J \n bmf = left( f_bmn right)_bmn in I_mathbfN in mathbbC^bmN\n  bmA =  left( mathrme^-2 pi mathrmi  bmn cdot bmk_j right)_j=1dotsJ bmn in I_mathbfN in mathbbC^J times bmN\nendaligned","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and where bmN = textprod(bmN). The adjoint can then be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" bmy = bmA^mathsfH  hatbmf","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where bmy in mathbbC^bmN.","category":"page"},{"location":"background/#NFFT","page":"Background","title":"NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is an approximative algorithm that realizes the NDFT in just mathcal O(bmN log bmN + J) steps. This is at the same level as the ordinary FFT with the exception of the additional linear term J, which is unavoidable since all nodes need to be touched as least once.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT has two important parameters that influence its accuracy:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"the window size parameter m in mathbbN\nthe oversampling factor sigma in mathbbR with sigma  1","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"From the latter we can derive tildebmN = sigma bmN in (2mathbbN)^D. As the definition indicates, the oversampling factor sigma is usually adjusted such that tildebmN consists of even integers.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT now approximates bmA by the product of three matrices","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA approx bmB bmF bmD","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmF in mathbbC^tildemathbfN times tildemathbfN is the regular DFT matrix.\nbmD in mathbbC^tildemathbfN times mathbfN is a diagonal matrix that additionally includes zero filling and the fftshift. We call this the deconvolution matrix.\nbmB in mathbbC^M times tildemathbfN is a sparse matrix implementing the discrete convolution with a window function hatvarphi. We call this the convolution matrix.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The NFFT is based on the convolution theorem. It applies a convolution in the non-equidistant domain, which is evaluated at equidistant sampling nodes. This convolution is then corrected in the equidistant domain by division with the inverse Fourier transform hatvarphi. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The adjoint NFFT matrix approximates bmA^mathsfH by","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"bmA^mathsfH approx bmD^mathsfH bmF^mathsfH  bmB^mathsfH ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Implementation-wise, the matrix-vector notation illustrates that the NFFT consists of three independent steps that are performed successively. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The multiplication with bmD is a scalar multiplication with the input-vector plus the shifting of data, which can be done inplace.\nThe FFT can be done with a high-performance FFT library such as the FFTW.\nThe multiplication with bmB needs to run only over a subset of the indices and is the most challenging step.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Since in practice the multiplication with bmB is also the most expensive step, an NFFT library needs to pay special attention to optimizing it appropriately.","category":"page"},{"location":"background/#Directional-NFFT","page":"Background","title":"Directional NFFT","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"In many cases one not just needs to apply a single NFFT but needs to apply many on different data. This leads us to the directional NFFT. The directional NFFT is defined as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  \tf_bmljbmr = sum_ bmn in I_bmN_textsub hatf_bmlbmnbmr  mathrme^-2pimathrmibmncdotbmk_j","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where now (bml bmk bmr) in I_mathbfN and I_bmN_textsub is a subset of I_bmN. The transform thus maps a D-dimensional tensor hatf_bmlbmnbmr to an R-dimensional tensor f_bmljbmr. bmN_textsub is thus a vector of length D-R+1. The indices bml and bmr can also have length zero. Thus, for R=1, the conventional NFFT arises as a special case of the directional NFFT.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"note: Note\nThe directional NFFT can also be considered to be a slicing of a tensor with subsequent application of a regular NFFT. But the aforementioned formulation can be used to implement a much more efficient algorithm than can be achieved with slicing.","category":"page"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at the software paper on the NFFT.jl. Further resources are nfft.org and finufft.readthedocs.io. You ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a Discrete Fourier Transform (DFT) with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the Fast Fourier Transform (FFT), the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width parameter m and the oversampling factor σ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NFFT.jl project serves two different purposes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provide a package AbstractNFFTs.jl that allows to use any NFFT Julia package such as NFFT3.jl or FINUFFT.jl using the same interface\nProvide a high-performance, multi-threaded reference implementation in pure Julia. This is realized in the Julia package NFFT.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The term NFFT.jl thus may either mean the entire Github project consisting of several packages or the concrete reference implementation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add NFFT","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages NFFT.jl and all its dependencies. Most importantly it installs the abstract interface package AbstractNFFTs.jl, which NFFT.jl implements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional NFFT related tools can be obtained by adding the package NFFTTools.jl. If you need support for CUDA you also need to install the package CuNFFT.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In case you want to use an alternative NFFT implementation such as NFFT3.jl or FINUFFT.jl we provide wrapper types allowing to use them as AbstractNFFTs implementations. They can be used like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AbstractNFFTs\njulia> include(joinpath(dirname(pathof(AbstractNFFTs)), \"..\", \"..\", \"Wrappers\", \"FINUFFT.jl\"))\njulia> include(joinpath(dirname(pathof(AbstractNFFTs)), \"..\", \"..\", \"Wrappers\", \"NFFT3.jl\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"This requires that you first add the package you want to use. ","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation starts with the Mathematical Background that properly defines the NDFT, the NFFT and its directional variants. You might want to skip this part if you are familiar with the notation and concepts of the NFFT. \nThen, an Overview about the usage of the NFFT functions is given in a tutorial style manner.  \nThen, an overview about Accuracy and Performance is given.\nThe section about Tools introduced some high-level functions that build upon the NFFT. For instance NFFT inversion is discussed in that section.\nIn the section about the Abstract Interface for NFFTs we outline how the package is divided into an interface package and implementation packages. This part is useful if you plan to use different NFFT implementations, e.g. one for the CPU and another for the GPU and would like to switch.\nFinally, the documentation contains an API index.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project. You can do so by citing the publication","category":"page"},{"location":"","page":"Home","title":"Home","text":"T. Knopp, M. Boberg and M. Grosser, NFFT.jl: Generic and Fast Julia Implementation of the Nonequidistant  Fast Fourier Transform, 2022 arXiv:2208.00049","category":"page"},{"location":"","page":"Home","title":"Home","text":"A BibTeX file NFFT.bib can be found in the root folder of the Github repository.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find bugs or have ideas for improvements please use the issue tracker. For general questions please use the discussions section on Github.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp\nRobert Dahl Jacobsen\nMirco Grosser\nJakob Assländer\nMosè Giordano","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of contributors can be found on the Github page.","category":"page"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The packages AbstractNFFT.jl and NFFT.jl are on purpose kept small and focussed. Additional tooling that relates to the NFFT is offloaded into a package NFFTTools.jl. ","category":"page"},{"location":"tools/#Sampling-Density","page":"Tools","title":"Sampling Density","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The first tool that NFFTTools.jl offers is the computation of the sampling density. To motivate this let us have a look at the normalized variant of the DFT matrix bmF. bmF is unitary, which means that","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":" bmF^mathsfH bmF = bmI ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"where bmI is the identity matrix. In other words, bmF^mathsfH is the inverse of bmF^mathsfH.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Now let's switch to the NFFT. Have you already wondered why we don't call the adjoint the inverse? Well it's because in general we have","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":" bmA^mathsfH bmA neq bmI ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"In fact, the inverse of the NFFT is a much more complicated subject since the linear system bmA bmf = hatbmf can have one, no or many solutions because bmAcan be under- or over-determined.","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The good news is that in most cases, with J approx N and no complete clustering of the sampling nodes, one can find a diagonal weighting matrix bmW = left( w_j right)_j=1^Jsuch that","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":" bmA^mathsfH bmW bmA approx bmI ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The weights w_j can be considered to we quadrature weights that account for the area covered by the node bmk_j. ","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"NFFTTools.jl provides the function sdc that takes an existing plan and calculated suitable density weights:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"weights = sdc(p, iters = 10)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The function implements the method proposed in Pipe & Menon, 1999. Mag Reson Med, 186, 179.","category":"page"},{"location":"tools/#Toeplitz-Kernel","page":"Tools","title":"Toeplitz Kernel","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"The aforementioned matrix bmA^mathsfH bmW bmA arises when solving linear system of the form","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"bmA bmf = hatbmf","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"which can be done via the normal equation","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"bmA^mathsfH bmW bmA bmf = bmA^mathsfH bmW hatbmf","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"The normal or Gram matrix bmA^mathsfH bmW bmA has a Toeplitz structure. For multi-dimensional NFFT is is a block Toeplitz matrix with Toeplitz blocks. A Toeplitz matrix (and its block variants) can be embedded into a circulant matrix of twice the size in each dimension. Circulant matrices are known to be diagonalizable by ordinary FFTs. This means we can multiply with bmA^mathsfH bmW bmA by just two FFTs of size 2bmN, which is basically the same amount of FFTs as are required for an NFFT-based calculation of matrix-vector products with bmA^mathsfH bmW bmA. But the important difference is that no convolution step is required for the Toeplitz-based approach. This can often lead to speedups, which are in particular important when using the Gram matrix in iterative solvers  (see Fessler et al., IEEE Trans. Sig. Proc., 53, 9 for the mathematical background).","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"With NFFTTools.jl one can calculate the kernel required to exploit the Toeplitz structure with the function calculateToeplitzKernel. Multiplications with the Gram matrix can then be done using the function convolveToeplitzKernel!. The following outlines a complete example for the usage of both functions:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"using NFFT, NFFTTools, FFTW\n\nN = (32, 32)                            # signal size\nÑ = 2 .* N                              # oversampled signal size\n\nk = Float32.(rand(2, 1000) .- 0.5)      # 2D sampling nodes\np = plan_nfft(k, Ñ)                     # 2D NFFT plan\nfftplan = plan_fft(zeros(ComplexF32, Ñ));\n\nλ = Array{ComplexF32}(undef, Ñ)         # pre-allocate Toeplitz kernel \ncalculateToeplitzKernel!(λ, p, k,fftplan)       # calculate Toeplitz kernel \n\ny = randn(ComplexF32, Ñ)\nconvolveToeplitzKernel!(y, λ)           # multiply with Gram matrix\n","category":"page"}]
}
