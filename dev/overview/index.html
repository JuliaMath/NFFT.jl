<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · NFFT</title><link rel="canonical" href="https://tknopp.github.io/NFFT.jl/overview/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NFFT logo"/></a><div class="docs-package-name"><span class="docs-autofit">NFFT</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started"><span>Getting Started</span></a></li><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Accuracy"><span>Accuracy</span></a></li><li><a class="tocitem" href="#Window-Functions"><span>Window Functions</span></a></li><li><a class="tocitem" href="#Precomputation"><span>Precomputation</span></a></li><li><a class="tocitem" href="#Block-Partitioning"><span>Block Partitioning</span></a></li><li><a class="tocitem" href="#Multi-Threading"><span>Multi-Threading</span></a></li><li><a class="tocitem" href="#Directional"><span>Directional</span></a></li></ul></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../abstract/">AbstractNFFTs</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/NFFT.jl/blob/master/docs/src/overview.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><h2 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h2><p>Basic usage of NFFT.jl is shown in the following example for 1D:</p><pre><code class="language-julia">using NFFT

J, N = 8, 16
k = range(-0.4, stop=0.4, length=J)  # nodes at which the NFFT is evaluated
f = randn(ComplexF64, J)             # data to be transformed
p = plan_nfft(k, N, reltol=1e-9)     # create plan
fHat = adjoint(p) * f                # calculate adjoint NFFT
y = p * fHat                         # calculate forward NFFT</code></pre><p>In the same way the 2D NFFT can be applied:</p><pre><code class="language-julia">J, N = 16, 32
k = rand(2, J) .- 0.5
f = randn(ComplexF64, J)
p = plan_nfft(k, (N,N), reltol=1e-9)
fHat = adjoint(p) * f
y = p * fHat</code></pre><p>Currently, the eltype of the arguments <code>f</code> and <code>fHat</code> must be compatible with that of the sampling nodes <code>k</code> used in the <code>plan_nfft</code> call. For example, if one wants to use <code>Float32</code> types to save memory, one can create the plan like this:</p><pre><code class="language-julia">k = Float32.(LinRange(-0.5,0.5,64))
p = plan_nfft(k, N)</code></pre><p>The plan will then internally use <code>Float32</code> types. The signals <code>f</code> and <code>fHat</code> then need to have the eltype <code>Complex{Float32}</code> or equivalently <code>ComplexF32</code>. Otherwise there will be error messages.</p><p>In the previous example, the output vector was allocated within the <code>*</code> method. To avoid this allocation one can use the interface</p><pre><code class="language-none">mul!(fHat, p, f)
mul!(y, adjoint(p), fHat)</code></pre><p>which allows to pass the output vector as the first argument.</p><p>One can also perform NFFT computations directly without first creating a plan:</p><pre><code class="language-none">fHat = nfft(k, f)
y = nfft_adjoint(k, N, fHat)</code></pre><p>These forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same sampling nodes <code>k</code>.  Note that <code>nfft_adjoint</code> requires the extra argument <code>N</code> since this cannot be derived from the input vector as can be done for <code>nfft</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The constructor <code>plan_nfft</code> is meant to be a generic factory function that can be implemented in different packages. If you want to use a concrete constructor of <code>NFFT.jl</code> use <code>NFFTPlan</code> instead. </p></div></div><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>The NFFT has the several parameters that can be passed as a keyword argument to the constructor or the <code>nfft</code> and the <code>nfft_adjoint</code> function.</p><table><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Description</th><th style="text-align: left">Example Values</th></tr><tr><td style="text-align: left"><code>reltol</code></td><td style="text-align: left">Relative tolerance that the NFFT achieves.</td><td style="text-align: left"><code>reltol</code> <span>$=10^{-9}$</span></td></tr><tr><td style="text-align: left"><code>m</code></td><td style="text-align: left">Kernel size parameter. The convolution matrix has <code>2m+1</code> non-zero entries around each sampling node in each dimension.</td><td style="text-align: left"><code>m</code> <span>$\in \{2,\dots,8\}$</span></td></tr><tr><td style="text-align: left"><code>σ</code></td><td style="text-align: left">Oversampling factor. The inner FFT is of size <code>σN</code></td><td style="text-align: left"><code>σ</code> <span>$\in [1.25, 2.0]$</span></td></tr><tr><td style="text-align: left"><code>window</code></td><td style="text-align: left">Convolution window <span>$\hat{\varphi}$</span></td><td style="text-align: left"><code>:kaiser_bessel</code></td></tr><tr><td style="text-align: left"><code>precompute</code></td><td style="text-align: left">Flag indicating the precomputation strategy for the convolution matrix</td><td style="text-align: left"><code>TENSOR</code></td></tr><tr><td style="text-align: left"><code>blocking</code></td><td style="text-align: left">Flag block partitioning should be used to speed up computation</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>sortNodes</code></td><td style="text-align: left">Flag if the nodes should be sorted in a lexicographic way</td><td style="text-align: left"><code>false</code></td></tr><tr><td style="text-align: left"><code>storeDeconvolutionIdx</code></td><td style="text-align: left">Flag if the deconvolve indices should be stored. Currently this option is necessary on the GPU</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><code>fftflags</code></td><td style="text-align: left">flags passed to the inner <code>AbstractFFT</code> as <code>flags</code>. This can for instance be <code>FFTW.MEASURE</code> in order to optimize the inner FFT</td><td style="text-align: left"><code>FFTW.ESTIMATE</code></td></tr></table><p>In practice the default values are properly chosen and there is in most cases no need to change them.  The only parameter you sometimes need to care about are the accuracy parameters <code>reltol</code>, <code>m</code>,<code>\sigma</code> and the <code>fftflags</code>.</p><h2 id="Accuracy"><a class="docs-heading-anchor" href="#Accuracy">Accuracy</a><a id="Accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy" title="Permalink"></a></h2><p>On a high-level it is possible to set the accuracy using the parameter <code>reltol</code>. It will automatically set the low-level parameters <code>m</code> and <code>\sigma</code>. You only need to change the later if you run into memory issues. It is important that you change only <code>reltol</code> or the pair <code>m</code>,<code>\sigma</code>.</p><p>The relation between <code>reltol</code>, <code>m</code>, and <code>σ</code> depends on the window function and the NFFT implementation. We use the formula</p><p class="math-container">\[w = 2m + 1 = \left\lceil \text{log}_{10} \frac{1}{\text{reltol}} \right\rceil + 1\]</p><p>which was verified for <code>σ</code> and the default window function. If you change the window function, you should use the parameter <code>m</code>, and <code>σ</code> instead of <code>reltol</code>.</p><h2 id="Window-Functions"><a class="docs-heading-anchor" href="#Window-Functions">Window Functions</a><a id="Window-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Window-Functions" title="Permalink"></a></h2><p>It is possible to change the internal window function <span>$\hat{\varphi}$</span>. Available are </p><ul><li><code>:gauss</code></li><li><code>:spline</code></li><li><code>:kaiser_bessel_rev</code></li><li><code>:kaiser_bessel</code> </li><li><code>:cosh_type</code></li></ul><p>and one can easily add more by extending the <a href="https://github.com/JuliaMath/NFFT.jl/blob/master/src/windowFunctions.jl">windowFunctions.jl</a> file in Github.</p><p>However, the possibility of changing the window function is only important for NFFT researcher and not for NFFT users. Right now <code>:kaiser_bessel</code> provides the best accuracy and thus there is no reason to change the parameter <code>window</code> to something different.</p><h2 id="Precomputation"><a class="docs-heading-anchor" href="#Precomputation">Precomputation</a><a id="Precomputation-1"></a><a class="docs-heading-anchor-permalink" href="#Precomputation" title="Permalink"></a></h2><p>There are different precomputation strategies available:</p><table><tr><th style="text-align: left">Value</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>NFFT.POLYNOMIAL</code></td><td style="text-align: left">This option approximates the window function by a polynomial with high degree and evaluates the polynomial during the actual convolution.</td></tr><tr><td style="text-align: left"><code>NFFT.LINEAR</code></td><td style="text-align: left">This option uses a look-up table to first sample the window function and later use linear interpolation during the actual convolution.</td></tr><tr><td style="text-align: left"><code>NFFT.FULL</code></td><td style="text-align: left">This option precomputes the entire convolution matrix and stores it as a <code>SparseMatrixCSC</code>. This option requires more memory and the longest precomputation time. This allows simple GPU implementations like realized in CuNFFT.</td></tr><tr><td style="text-align: left"><code>NFFT.TENSOR</code></td><td style="text-align: left">This option calculates the window on demand but exploits the tensor product structure for multi-dimensional plans.</td></tr></table><p>Again you don&#39;t need to change this parameter since the default <code>NFFT.POLYNOMIAL</code> is a good choice in most situations. You may want to use <code>NFFT.TENSOR</code> if you are applying the same transform multiple times since it is a little bit faster than <code>NFFT.POLYNOMIAL</code> but has a higher pre-computation time.</p><h2 id="Block-Partitioning"><a class="docs-heading-anchor" href="#Block-Partitioning">Block Partitioning</a><a id="Block-Partitioning-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Partitioning" title="Permalink"></a></h2><p>Internally NFFT can use block partitioning to speedup computation. It helps in two ways</p><ul><li>It helps improving the memory efficiency by grouping sampling points together which allows for better use of CPU caches.</li><li>Block partitioning is a mandatory to enable multi-threading in the adjoint NFFT, which would otherwise not be possible because of a data dependency.</li></ul><p>We enable block partitioning by default since it helps also in the single-threaded case and thus, there usually is no reason to switch it off.</p><h2 id="Multi-Threading"><a class="docs-heading-anchor" href="#Multi-Threading">Multi-Threading</a><a id="Multi-Threading-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Threading" title="Permalink"></a></h2><p>Most parts of NFFT are multi-threaded when running on the CPU. To this end, start Julia with the option</p><pre><code class="language-none">julia -t T</code></pre><p>where <code>T</code> it the number of desired threads. NFFT.jl will use all threads that are specified. </p><h2 id="Directional"><a class="docs-heading-anchor" href="#Directional">Directional</a><a id="Directional-1"></a><a class="docs-heading-anchor-permalink" href="#Directional" title="Permalink"></a></h2><p>There are special methods for computing 1D NFFT&#39;s for each 1D slice along a particular dimension of a higher dimensional array.</p><pre><code class="language-julia">J = 11

y = rand(J) .- 0.5
N = (16,20)
p1 = plan_nfft(y, N, dims=1)
f = randn(ComplexF64, N)
fHat = p1 * f</code></pre><p>Here <code>size(f) = (16,20)</code> and <code>size(fHat) = (11,20)</code> since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension</p><pre><code class="language-julia">p2 = plan_nfft(y, N, dims=2)
fHat = p2 * f</code></pre><p>Now <code>size(fHat) = (16,11)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../background/">« Background</a><a class="docs-footer-nextpage" href="../performance/">Performance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 July 2024 08:35">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
