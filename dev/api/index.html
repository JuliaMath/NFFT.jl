<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · NFFT</title><meta name="title" content="API · NFFT"/><meta property="og:title" content="API · NFFT"/><meta property="twitter:title" content="API · NFFT"/><meta name="description" content="Documentation for NFFT."/><meta property="og:description" content="Documentation for NFFT."/><meta property="twitter:description" content="Documentation for NFFT."/><meta property="og:url" content="https://tknopp.github.io/NFFT.jl/api/"/><meta property="twitter:url" content="https://tknopp.github.io/NFFT.jl/api/"/><link rel="canonical" href="https://tknopp.github.io/NFFT.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NFFT logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NFFT</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../abstract/">AbstractNFFTs</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMath/NFFT.jl/blob/master/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>In the following, you find the documentation of some, and hopefully soon all, exported functions of the <a href="https://github.com/JuliaMath/NFFT.jl">NFFT.jl</a> package family:</p><p><a href="https://github.com/JuliaMath/NFFT/AbstractNFFTs">AbstractNFFTs.jl</a></p><ul><li><a href="#AbstractNFFTs.AbstractComplexFTPlan"><code>AbstractNFFTs.AbstractComplexFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractFTPlan"><code>AbstractNFFTs.AbstractFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNFCTPlan"><code>AbstractNFFTs.AbstractNFCTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNFFTPlan"><code>AbstractNFFTs.AbstractNFFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNFSTPlan"><code>AbstractNFFTs.AbstractNFSTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNNFFTPlan"><code>AbstractNFFTs.AbstractNNFFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractRealFTPlan"><code>AbstractNFFTs.AbstractRealFTPlan</code></a></li><li><a href="#AbstractNFFTs.accuracyParams-Tuple{}"><code>AbstractNFFTs.accuracyParams</code></a></li><li><a href="#AbstractNFFTs.convolve!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}"><code>AbstractNFFTs.convolve!</code></a></li><li><a href="#AbstractNFFTs.convolve_transpose!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}"><code>AbstractNFFTs.convolve_transpose!</code></a></li><li><a href="#AbstractNFFTs.nfct"><code>AbstractNFFTs.nfct</code></a></li><li><a href="#AbstractNFFTs.nfct_transpose"><code>AbstractNFFTs.nfct_transpose</code></a></li><li><a href="#AbstractNFFTs.nfft"><code>AbstractNFFTs.nfft</code></a></li><li><a href="#AbstractNFFTs.nfft_adjoint"><code>AbstractNFFTs.nfft_adjoint</code></a></li><li><a href="#AbstractNFFTs.nfst"><code>AbstractNFFTs.nfst</code></a></li><li><a href="#AbstractNFFTs.nfst_transpose"><code>AbstractNFFTs.nfst_transpose</code></a></li><li><a href="#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T"><code>AbstractNFFTs.nodes!</code></a></li><li><a href="#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{NFFTBackend, Type{&lt;:Array}, Matrix{T}, NTuple{D, Int64}, Vararg{Any}}} where {T, D}"><code>AbstractNFFTs.plan_nfft</code></a></li><li><a href="#AbstractNFFTs.set_active_backend!-Tuple{Module}"><code>AbstractNFFTs.set_active_backend!</code></a></li><li><a href="#AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_in</code></a></li><li><a href="#AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_out</code></a></li></ul><p><a href="https://github.com/JuliaMath/NFFT.jl">NFFT.jl</a></p><ul><li><a href="#NFFT.precomputeLinInterp-NTuple{5, Any}"><code>NFFT.precomputeLinInterp</code></a></li></ul><p><a href="https://github.com/JuliaMath/NFFT/AbstractNFFTs">NFFTTools.jl</a></p><ul><li><a href="#NFFTTools._fill_similar-Union{Tuple{T}, Tuple{AbstractArray, T, Union{Integer, NTuple{N, Int64} where N}}} where T"><code>NFFTTools._fill_similar</code></a></li><li><a href="#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><code>NFFTTools.calculateToeplitzKernel</code></a></li><li><a href="#NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T"><code>NFFTTools.calculateToeplitzKernel!</code></a></li><li><a href="#NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Vararg{Any, 4}}} where {T, N}"><code>NFFTTools.convolveToeplitzKernel!</code></a></li><li><a href="#NFFTTools.sdc-Union{Tuple{AbstractNFFTPlan{T, D, 1}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D}"><code>NFFTTools.sdc</code></a></li><li><a href="#NFFTTools.sdc!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, 1}, Int64, AbstractVector{T}, AbstractVector, AbstractArray, AbstractVector, AbstractArray}} where {T&lt;:Real, D}"><code>NFFTTools.sdc!</code></a></li><li><a href="#NFFTTools.sdc!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, 1}, Int64, AbstractVector{T}, AbstractVector, AbstractArray}} where {T&lt;:Real, D}"><code>NFFTTools.sdc!</code></a></li></ul><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractComplexFTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractComplexFTPlan"><code>AbstractNFFTs.AbstractComplexFTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractComplexFTPlan{T,D,R}</p><p>Abstract type for either an NFFT plan or an NNFFT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L51-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractFTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractFTPlan"><code>AbstractNFFTs.AbstractFTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractFTPlan{T,D,R}</p><p>Abstract type for any NFFT-like plan (NFFT, NFFT, NFCT, NFST).</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L31-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractNFCTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractNFCTPlan"><code>AbstractNFFTs.AbstractNFCTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractNFCTPlan{T,D,R}</p><p>Abstract type for an NFCT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L72-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractNFFTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractNFFTPlan"><code>AbstractNFFTs.AbstractNFFTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractNFFTPlan{T,D,R}</p><p>Abstract type for an NFFT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L62-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractNFSTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractNFSTPlan"><code>AbstractNFFTs.AbstractNFSTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractNFSTPlan{T,D,R}</p><p>Abstract type for an NFST plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L82-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractNNFFTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractNNFFTPlan"><code>AbstractNFFTs.AbstractNNFFTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractNNFFTPlan{T,D,R}</p><p>Abstract type for an NNFFT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L92-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.AbstractRealFTPlan"><a class="docstring-binding" href="#AbstractNFFTs.AbstractRealFTPlan"><code>AbstractNFFTs.AbstractRealFTPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractRealFTPlan{T,D,R}</p><p>Abstract type for either an NFCT plan or an NFST plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L41-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.accuracyParams-Tuple{}"><a class="docstring-binding" href="#AbstractNFFTs.accuracyParams-Tuple{}"><code>AbstractNFFTs.accuracyParams</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>accuracyParams(; [m, σ, reltol]) -&gt; m, σ, reltol</p><p>Calculate accuracy parameters m, σ, reltol based on either</p><ul><li>reltol</li></ul><p>or</p><ul><li>m, σ</li></ul><p>TODO: Right now, the oversampling parameter is not taken into account, i.e. σ=2.0 is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/misc.jl#L56-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.convolve!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#AbstractNFFTs.convolve!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}"><code>AbstractNFFTs.convolve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>convolve!(p::AbstractNFFTPlan{T,D,R}, g::AbstractArray, fHat::AbstractArray)</p><p>Overwrite <code>R</code>-dimensional array <code>fHat</code> (often R=1, and <code>fHat</code> has length <code>only(p.size_in)</code>) with the result of &quot;convolution&quot; (i.e., interpolation) between <code>D</code>-dimensional equispaced input array <code>g</code> (often of size <code>p.Ñ</code> which is not part of abstract interface) and the interpolation kernel in NFFT plan <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L221-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.convolve_transpose!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#AbstractNFFTs.convolve_transpose!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}"><code>AbstractNFFTs.convolve_transpose!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convolve_transpose!(p::AbstractNFFTPlan{T,D,R}, fHat::AbstractArray, g::AbstractArray)</code></pre><p>Adjoint of <code>convolve!</code> operation, where <code>D</code>-dimensional equispaced array <code>g</code> is overwritten based on the values of <code>R</code>-dimensional input array <code>fHat</code> and the interpolation kernel in NFFT plan <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L234-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nfct"><a class="docstring-binding" href="#AbstractNFFTs.nfct"><code>AbstractNFFTs.nfct</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nfct(k, f, rest...; kwargs...)
nfct(backend, k, f, rest...; kwargs...)</code></pre><p>calculates the nfct of the array <code>f</code> for the nodes contained in the matrix <code>k</code> The output is a vector of length M=<code>size(nodes,2)</code>.</p><p>Uses the active AbstractNFFTs <code>backend</code> if no <code>backend</code> argument is provided. Backends can be activated with <code>BackendModule.activate!()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L92-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nfct_transpose"><a class="docstring-binding" href="#AbstractNFFTs.nfct_transpose"><code>AbstractNFFTs.nfct_transpose</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nfct_transpose(k, N, fHat, rest...; kwargs...)
nfct_transpose(backend, k, N, fHat, rest...; kwargs...)</code></pre><p>calculates the transpose nfct of the vector <code>fHat</code> for the nodes contained in the matrix <code>k</code>. The output is an array of size <code>N</code>.</p><p>Uses the active AbstractNFFTs <code>backend</code> if no <code>backend</code> argument is provided. Backends can be activated with <code>BackendModule.activate!()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L102-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nfft"><a class="docstring-binding" href="#AbstractNFFTs.nfft"><code>AbstractNFFTs.nfft</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nfft(k, f, rest...; kwargs...)
nfft(backend, k, f, rest...; kwargs...)</code></pre><p>calculates the nfft of the array <code>f</code> for the nodes contained in the matrix <code>k</code> The output is a vector of length M=<code>size(nodes,2)</code>.</p><p>Uses the active AbstractNFFTs <code>backend</code> if no <code>backend</code> argument is provided. Backends can be activated with <code>BackendModule.activate!()</code>. Backends can also be set with a scoped value overriding the current active backend within a scope:</p><pre><code class="language-julia hljs">julia&gt; NFFT.activate!()

julia&gt; nfft(k, f, rest...; kwargs...) # uses NFFT

julia&gt; with(nfft_backend =&gt; NonuniformFFTs.backend()) do
          nfft(k, f, rest...; kwargs...) # uses NonuniformFFTs
       end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L49-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nfft_adjoint"><a class="docstring-binding" href="#AbstractNFFTs.nfft_adjoint"><code>AbstractNFFTs.nfft_adjoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nfft_adjoint(k, N, fHat, rest...; kwargs...)
nfft_adjoint(backend, k, N, fHat, rest...; kwargs...)</code></pre><p>calculates the adjoint nfft of the vector <code>fHat</code> for the nodes contained in the matrix <code>k</code>. The output is an array of size <code>N</code>.</p><p>Uses the active AbstractNFFTs <code>backend</code> if no <code>backend</code> argument is provided. Backends can be activated with <code>BackendModule.activate!()</code>. Backends can also be set with a scoped value overriding the current active backend within a scope:</p><pre><code class="language-julia hljs">julia&gt; NFFT.activate!()

julia&gt; nfft_adjoint(k, N, fHat, rest...; kwargs...) # uses NFFT

julia&gt; with(nfft_backend =&gt; NonuniformFFTs.backend()) do
          nfft_adjoint(k, N, fHat, rest...; kwargs...) # uses NonuniformFFTs
       end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L70-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nfst"><a class="docstring-binding" href="#AbstractNFFTs.nfst"><code>AbstractNFFTs.nfst</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nfst(k, f, rest...; kwargs...)
nfst(backend, k, f, rest...; kwargs...)</code></pre><p>calculates the nfst of the array <code>f</code> for the nodes contained in the matrix <code>k</code> The output is a vector of length M=<code>size(nodes,2)</code>.</p><p>Uses the active AbstractNFFTs <code>backend</code> if no <code>backend</code> argument is provided. Backends can be activated with <code>BackendModule.activate!()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L113-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nfst_transpose"><a class="docstring-binding" href="#AbstractNFFTs.nfst_transpose"><code>AbstractNFFTs.nfst_transpose</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nfst_transpose(k, N, fHat, rest...; kwargs...)
nfst_transpose(backend, k, N, fHat, rest...; kwargs...)</code></pre><p>calculates the transpose nfst of the vector <code>fHat</code> for the nodes contained in the matrix <code>k</code>. The output is an array of size <code>N</code>.</p><p>Uses the active AbstractNFFTs <code>backend</code> if no <code>backend</code> argument is provided. Backends can be activated with <code>BackendModule.activate!()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L123-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T"><a class="docstring-binding" href="#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T"><code>AbstractNFFTs.nodes!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nodes!(p, k) -&gt; p</code></pre><p>Change nodes <code>k</code> in the plan <code>p</code> operation and return the plan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L206-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.set_active_backend!-Tuple{Module}"><a class="docstring-binding" href="#AbstractNFFTs.set_active_backend!-Tuple{Module}"><code>AbstractNFFTs.set_active_backend!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_active_backend!(back::Union{Missing, Module, AbstractNFFTBackend})</code></pre><p>Set the default NFFT plan backend. A module <code>back</code> must implement <code>back.backend()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L12-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><a class="docstring-binding" href="#AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_in</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">size_in(p)</code></pre><p>Size of the input array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has <code>D</code> entries. Note that this will be the output size for the transposed / adjoint operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L188-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><a class="docstring-binding" href="#AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_out</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">size_out(p)</code></pre><p>Size of the output array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has <code>R</code> entries.  Note that this will be the input size for the transposed / adjoint operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L197-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractComplexFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractComplexFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    *(p, f) -&gt; fHat</code></pre><p>For a <strong>non</strong>-directional <code>D</code> dimensional plan <code>p</code> this calculates the NFFT/NNFFT of a <code>D</code> dimensional array <code>f</code> of size <code>N</code>. <code>fHat</code> is a vector of length <code>M</code>. (<code>M</code> and <code>N</code> are defined in the plan creation)</p><p>For a <strong>directional</strong> <code>D</code> dimensional plan <code>p</code> both <code>f</code> and <code>fHat</code> are <code>D</code> dimensional arrays, and the dimension specified in the plan creation is affected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L163-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractRealFTPlan{T}, AbstractArray{U, D}}} where {T, U, D}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractRealFTPlan{T}, AbstractArray{U, D}}} where {T, U, D}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    *(p, f) -&gt; fHat</code></pre><p>For a <strong>non</strong>-directional <code>D</code> dimensional plan <code>p</code> this calculates the NFCT/NFST of a <code>D</code> dimensional array <code>f</code> of size <code>N</code>. <code>fHat</code> is a vector of length <code>M</code>. (<code>M</code> and <code>N</code> are defined in the plan creation)</p><p>For a <strong>directional</strong> <code>D</code> dimensional plan <code>p</code> both <code>f</code> and <code>fHat</code> are <code>D</code> dimensional arrays, and the dimension specified in the plan creation is affected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/derived.jl#L212-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractFTPlan{T}, AbstractArray}} where T"><a class="docstring-binding" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractFTPlan{T}, AbstractArray}} where T"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mul!(fHat, p, f) -&gt; fHat</code></pre><p>Inplace NFFT/NFCT/NFST/NNFFT transforming the <code>D</code> dimensional array <code>f</code> to the <code>R</code> dimensional array <code>fHat</code>. The transformation is applied along <code>D-R+1</code> dimensions specified in the plan <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L164-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, &lt;:AbstractComplexFTPlan{T}}, AbstractArray}} where T"><a class="docstring-binding" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, &lt;:AbstractComplexFTPlan{T}}, AbstractArray}} where T"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mul!(f, p, fHat) -&gt; f</code></pre><p>Inplace adjoint NFFT/NNFFT transforming the <code>R</code> dimensional array <code>fHat</code> to the <code>D</code> dimensional array <code>f</code>. The transformation is applied along <code>D-R+1</code> dimensions specified in the plan <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L172-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Transpose{T, &lt;:AbstractRealFTPlan{T}}, AbstractArray}} where T"><a class="docstring-binding" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Transpose{T, &lt;:AbstractRealFTPlan{T}}, AbstractArray}} where T"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mul!(f, p, fHat) -&gt; f</code></pre><p>Inplace transposed NFCT/NFST transforming the <code>R</code> dimensional array <code>fHat</code> to the <code>D</code> dimensional array <code>f</code>. The transformation is applied along <code>D-R+1</code> dimensions specified in the plan <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.9.1/src/interface.jl#L180-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{NFFTBackend, Type{&lt;:Array}, Matrix{T}, NTuple{D, Int64}, Vararg{Any}}} where {T, D}"><a class="docstring-binding" href="#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{NFFTBackend, Type{&lt;:Array}, Matrix{T}, NTuple{D, Int64}, Vararg{Any}}} where {T, D}"><code>AbstractNFFTs.plan_nfft</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NFFT.plan_nfft(k::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)</code></pre><p>compute a plan for the NFFT of a size-<code>N</code> array at the nodes contained in <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.14.3/src/NFFT.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFT.precomputeLinInterp-NTuple{5, Any}"><a class="docstring-binding" href="#NFFT.precomputeLinInterp-NTuple{5, Any}"><code>NFFT.precomputeLinInterp</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Precompute the look up table for the window function φ.</p><p>Remarks:</p><ul><li>Only the positive half is computed</li><li>The window is computed for the interval [0, (m)/Ñ]. The reason for the +2 is that we do evaluate the window function outside its interval, since x does not necessary match the sampling points</li><li>The window has K+1 entries and during the index calculation we multiply with the factor K/(m).</li><li>It is very important that K/(m) is an integer since our index calculation exploits this fact. We therefore always use <code>Int(K/(m))</code>instead of <code>K÷(m)</code> since this gives an error while the later variant would silently error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.14.3/src/precomputation.jl#L277-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools._fill_similar-Union{Tuple{T}, Tuple{AbstractArray, T, Union{Integer, NTuple{N, Int64} where N}}} where T"><a class="docstring-binding" href="#NFFTTools._fill_similar-Union{Tuple{T}, Tuple{AbstractArray, T, Union{Integer, NTuple{N, Int64} where N}}} where T"><code>NFFTTools._fill_similar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">out = _fill_similar(array, v::T, dims) where T</code></pre><p>Return an allocated array similar to <code>array</code> filled with value <code>v</code>.</p><p>This 2-step initialization helper function is needed to accommodate GPU array types. The more obvious statement <code>weights = fill(v, dims)</code> can lead to the wrong array type and cause GPU tests to fail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/samplingDensity.jl#L7-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T"><a class="docstring-binding" href="#NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T"><code>NFFTTools.calculateToeplitzKernel!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)</code></pre><p>Calculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in <code>f</code>, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. <a href="https://cds.ismrm.org/ismrm-2001/PDF3/0767.pdf">Wajer, F. T. A. W., and K. P. Pruessmann. &quot;Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.&quot; Proc. Intl. Soc. Mag. Res. Med. 2001.</a>). The type of the kernel <code>f</code> has to be <code>Complex{T}</code>, i.e. the complex of the k-space trajectory&#39;s type; for speed and memory efficiecy, call this function with <code>Float32.(tr)</code>, and set the type of <code>f</code> accordingly.</p><p><strong>Required Arguments</strong></p><ul><li><code>f::Array{T}</code>: Array in which the kernel will be written.</li><li><code>p::AbstractNFFTPlan</code>: NFFTPlan with the same dimensions as <code>tr</code>, which will be overwritten in place.</li><li><code>tr::Matrix{T}</code>: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. <code>tr[i] ∈ [-0.5, 0.5] ∀ i</code>. The matrix has the size <code>2 x Nsamples</code> for 2D imaging with a trajectory length <code>Nsamples</code>, and <code>3 x Nsamples</code> for 3D imaging.</li><li><code>fftplan</code>: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with <code>fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NFFTTools.FFTW

julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(rng, 2, 1000) .- 0.5);

julia&gt; p = plan_nfft(trj, (2Nx,2Nx))
NFFTPlan with 1000 sampling points for an input array of size(64, 64) and an output array of size(1000,) with dims 1:2

julia&gt; fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);

julia&gt; λ = Array{ComplexF32}(undef, 2Nx, 2Nx);

julia&gt; calculateToeplitzKernel!(λ, p, trj, fftplan);

julia&gt; y = randn(rng, ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(y, λ);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/Toeplitz.jl#L95-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><a class="docstring-binding" href="#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><code>NFFTTools.calculateToeplitzKernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculateToeplitzKernel(shape, tr::Matrix{T}[; m = 4, σ = 2.0, window = :kaiser_bessel, fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])</code></pre><p>Calculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of <code>shape</code>, as the Toeplitz trick requires an oversampling factor of 2 (cf. <a href="https://cds.ismrm.org/ismrm-2001/PDF3/0767.pdf">Wajer, F. T. A. W., and K. P. Pruessmann. &quot;Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.&quot; Proc. Intl. Soc. Mag. Res. Med. 2001.</a>). The type of the kernel is <code>Complex{T}</code>, i.e. the complex of the k-space trajectory&#39;s type; for speed and memory efficiency, call this function with <code>Float32.(tr)</code>, and the kernel will also be <code>Float32</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>shape::NTuple(Int)</code>: size of the image; e.g. <code>(256, 256)</code> for 2D imaging, or <code>(256,256,128)</code> for 3D imaging</li><li><code>tr::Matrix{T}</code>: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. <code>tr[i] ∈ [-0.5, 0.5] ∀ i</code>. The matrix has the size <code>2 x Nsamples</code> for 2D imaging with a trajectory length <code>Nsamples</code>, and <code>3 x Nsamples</code> for 3D imaging.</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>m::Int</code>: nfft kernel size (used to calculate the Toeplitz kernel); <code>default = 4</code></li><li><code>σ::Number</code>: nfft oversampling factor during the calculation of the Toeplitz kernel; <code>default = 2</code></li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>fftplan</code>: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. <code>default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE)</code>. If this constructor is used many times, it is worth to precompute the plan with <code>plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE)</code> and reuse it.</li><li><code>kwargs</code>: Passed on to <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.plan_fft!"><code>plan_fft!</code></a> via <code>NFFTPlan</code>; can be used to modify the flags <code>flags=FFTW.ESTIMATE, timelimit=Inf</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(rng, 2, 1000) .- 0.5);

julia&gt; λ = calculateToeplitzKernel((Nx, Nx), trj)
64×64 Matrix{ComplexF32}:
 -1528.64-170.936im  -622.032+56.4626im  …   2570.27-41.6055im
   3685.0+276.482im   2282.33-162.009im      2142.57-63.9413im
 -125.272-342.877im   819.441+228.404im      4293.36+130.336im
  940.796+31.5781im  -852.504+82.8948im      2681.78+180.963im
  445.039-252.226im  -1552.49+137.753im     -2037.24+39.6851im
  493.161+173.293im   664.534-58.8202im  …   1463.51+39.2481im
  332.265-180.768im   -2650.6+66.2951im     -2778.37-31.7731im
  2079.48-127.658im   4891.04+242.131im      3734.65+340.2im
  120.836-265.792im   10931.5+151.319im      4528.12+53.2504im
 -1247.63+356.045im  -198.919-241.572im       46.912-143.504im
         ⋮                               ⋱
 -340.961+142.965im   6010.83-28.4918im  …   2779.73+69.5765im
 -1826.62-161.638im   1103.42+47.1655im      2479.09-50.9026im
  2267.81+80.567im    1044.85+33.9058im      2327.04+131.974im
  1467.38-89.7949im   3410.85-24.6781im      1980.45-122.746im
   167.15+342.008im   1476.08-227.535im      2143.39-129.466im
 -724.138-204.324im   1686.02+89.8505im  …  -244.694-8.21769im
  237.304-84.753im   -1067.19+199.226im     -128.015+297.294im
  1848.84+50.5511im   1926.33-165.024im     -937.614-263.092im
  1912.83-152.94im    741.748+267.413im     -343.194+365.481im

julia&gt; y = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(y, λ)
32×32 Matrix{ComplexF32}:
 -718.038+2035.75im  -1771.79+191.592im  …  -1087.95+260.256im
 -472.432+473.74im   -1894.01+1138.22im     -295.522-647.603im
  139.463+1137.28im    184.53+228.995im      788.817-355.36im
  2966.54-1767.96im   255.169+590.332im      341.963+94.7469im
  -594.67-538.93im    180.487-566.905im      69.4853+481.47im
 -1004.42-111.931im   2439.67-323.525im  …   -448.47+1459.57im
 -341.784+49.591im   -268.101-750.184im      1309.23-108.091im
  189.394+638.56im   -821.709+121.441im      100.152-914.375im
 -192.401-702.179im  -1564.33-536.778im       1448.4-971.389im
  492.427-1121.14im  -3270.99+249.791im     -245.744+1659.15im
         ⋮                               ⋱
  1309.34+98.404im    73.0096-1181.38im      557.821-1096.24im
  907.312+129.232im  -44.5222+1075.8im      -879.056-180.416im
 -1020.87-671.83im   -1019.44-778.932im  …  -878.007+2165.44im
 -392.366-745.654im  -279.611-1023.18im      804.285-51.4734im
 -1139.86-549.792im  -1135.39+1236.09im      538.431+1891.79im
  391.965+974.582im  -1445.21-1113.64im      1172.98+116.43im
 -870.086-1002.25im   1100.69+846.779im     -377.282-602.989im
  928.376-163.128im  -1009.71+1075.25im  …  -444.653-140.651im
  268.106+635.919im   919.454-170.406im      233.847-1058.75im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/Toeplitz.jl#L13-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Vararg{Any, 4}}} where {T, N}"><a class="docstring-binding" href="#NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Vararg{Any, 4}}} where {T, N}"><code>NFFTTools.convolveToeplitzKernel!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convolveToeplitzKernel!(y::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])</code></pre><p>Convolves the image <code>y</code> with the Toeplitz kernel <code>λ</code> and overwrites <code>y</code> with the result. <code>y</code> is also returned for convenience. As this function is commonly applied many times, it is highly recommended to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.</p><p><strong>Required Arguments</strong></p><ul><li><code>y::Array{T,N}</code>: Input image that will be overwritten with the result. <code>y</code> is a matrix (<code>N=2</code>) for 2D imaging and a 3D tensor (<code>N=3</code>) for 3D imaging. The type of the elements <code>T</code> must match the ones of <code>λ</code>.</li><li><code>λ::Array{T,N}</code>: Toeplitz kernel, which as to be the same type as <code>k</code>, but twice the size due to the required oversampling (cf. <a href="#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><code>calculateToeplitzKernel</code></a>).</li></ul><p><strong>Optional, but highly recommended Arguments</strong></p><ul><li><code>fftplan</code>: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with <code>fftplan = plan_fft(λ; flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li><li><code>ifftplan</code>: plan for the oversampled inverse FFT. Calculate, e.g., with <code>ifftplan = plan_ifft(λ; flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li><li><code>xOS1</code>: pre-allocated array of the size of <code>λ</code>. Pre-allocate with <code>xOS1 = similar(λ)</code>.</li><li><code>xOS2</code>: pre-allocated array of the size of <code>λ</code>. Pre-allocate with <code>xOS2 = similar(λ)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NFFTTools.FFTW

julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(rng, 2, 1000) .- 0.5);

julia&gt; λ = calculateToeplitzKernel((Nx, Nx), trj);

julia&gt; xOS1 = similar(λ);

julia&gt; xOS2 = similar(λ);

julia&gt; fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);

julia&gt; ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);

julia&gt; y = randn(rng, ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(y, λ, fftplan, ifftplan, xOS1, xOS2)
32×32 Matrix{ComplexF32}:
  -783.38-230.709im  -41.2715-196.622im  …   1051.97+1655.19im
  306.303+931.416im  -212.223-960.781im     -270.816-4.68915im
  1018.79+974.724im   1204.28-1286.06im      398.504+298.177im
   138.68+346.405im   225.016-586.742im      397.565-205.818im
  402.152+725.267im   731.119-307.097im      810.773-244.329im
  680.202-682.887im  -7.59145-254.964im  …  -1219.87-1119.43im
 -64.0526-909.241im   61.5645+1199.98im       253.19-630.097im
 -835.246-993.775im  -1561.78+969.924im     -7.08272+1755.43im
   163.15-212.155im   1282.88+250.916im      819.356+1184.85im
  71.7218-933.054im   772.495-39.3827im      495.359+2949.17im
         ⋮                               ⋱
 -499.452-192.12im   -589.649+1561.74im      1544.92+126.5im
 -347.838+791.432im  -112.339+269.57im      -1068.77+452.493im
  1861.73-494.369im   416.406+499.465im  …  -1856.07-211.381im
   176.94+984.977im   874.282+41.8216im     -1717.71+1169.11im
  516.513+270.692im   531.069+1907.76im     -697.752+42.6127im
  -65.358-411.893im  -1299.86-868.781im     -285.473-1803.2im
 -15.1395+439.582im   84.4428+2026.06im      13.6334+24.6603im
 -1146.97+1632.87im  -208.162+1114.2im   …   -295.39+854.479im
  502.986+591.013im  -1013.11+97.8801im      617.683+17.4492im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/Toeplitz.jl#L170-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools.sdc!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, 1}, Int64, AbstractVector{T}, AbstractVector, AbstractArray, AbstractVector, AbstractArray}} where {T&lt;:Real, D}"><a class="docstring-binding" href="#NFFTTools.sdc!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, 1}, Int64, AbstractVector{T}, AbstractVector, AbstractArray, AbstractVector, AbstractArray}} where {T&lt;:Real, D}"><code>NFFTTools.sdc!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sdc!( ... )</code></pre><p>This version scales the weights such that <span>$A&#39; D(w) A 1_N ≈ 1_N$</span>. Find <span>$c ∈ ℝ$</span> that minimizes <span>$‖u - c * v‖₂$</span> where <span>$u ≜ 1_N$</span> (vector of ones) and <span>$v ≜ A&#39; D(w) A 1_N$</span>, and then scale <code>w</code> by that <code>c</code>. The analytical solution is <span>$c = real(u&#39;v) / ‖v‖² = real(sum(v)) / ‖v‖².$</span></p><p>Ideally this function should be (nearly) non-allocating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/samplingDensity.jl#L121-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools.sdc!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, 1}, Int64, AbstractVector{T}, AbstractVector, AbstractArray}} where {T&lt;:Real, D}"><a class="docstring-binding" href="#NFFTTools.sdc!-Union{Tuple{D}, Tuple{T}, Tuple{AbstractNFFTPlan{T, D, 1}, Int64, AbstractVector{T}, AbstractVector, AbstractArray}} where {T&lt;:Real, D}"><code>NFFTTools.sdc!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>weights = sdc!( p::AbstractNFFTPlan, iters, weights, weights_tmp, workg) Compute sampling density compensation <code>weights</code> without performing any final scaling step.</p><p>Ideally this function should be (nearly) non-allocating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/samplingDensity.jl#L86-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NFFTTools.sdc-Union{Tuple{AbstractNFFTPlan{T, D, 1}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D}"><a class="docstring-binding" href="#NFFTTools.sdc-Union{Tuple{AbstractNFFTPlan{T, D, 1}}, Tuple{D}, Tuple{T}} where {T&lt;:Real, D}"><code>NFFTTools.sdc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>weights = sdc(plan::{Abstract}NFFTPlan; iters=20, ...)</p><p>Compute weights for sample density compensation for given NFFT <code>plan</code> Uses method of Pipe &amp; Menon, Mag Reson Med, 44(1):179-186, Jan. 1999. DOI: 10.1002/(SICI)1522-2594(199901)41:1&lt;179::AID-MRM25&gt;3.0.CO;2-V The function applies <code>iters</code> iterations of that method.</p><p>The scaling here such that if the plan were 1D with N nodes equispaced from -0.5 to 0.5-1/N, then the returned weights are ≈ 1/N.</p><p>The weights are scaled such that <span>$A&#39; diag(w) A 1_N ≈ 1_N$</span>.</p><p>The returned vector is real, positive values of length <code>plan.J</code>.</p><p>This method <em>almost</em> conforms to the <code>AbstractNFFT</code> interface except that it uses <code>p.Ñ</code> and <code>p.tmpVec</code> that are not part of that interface.</p><p>There are several named keyword arguments that are work buffers that are all mutated: <code>weights weights_tmp workg workf workv</code>. If the caller provides all of those, then this function should make only small allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/v0.3.0/src/samplingDensity.jl#L36-L58">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../abstract/">« AbstractNFFTs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 21 January 2026 07:53">Wednesday 21 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
