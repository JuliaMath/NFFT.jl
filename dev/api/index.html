<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · NFFT</title><link rel="canonical" href="https://tknopp.github.io/NFFT.jl/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NFFT logo"/></a><div class="docs-package-name"><span class="docs-autofit">NFFT</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../abstract/">AbstractNFFTs</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/NFFT.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>In the following, you find the documentation of some, and hopefully soon all, exported functions of the <a href="https://github.com/JuliaMath/NFFT.jl">NFFT.jl</a> package family:</p><p><a href="https://github.com/JuliaMath/NFFT/AbstractNFFTs">AbstractNFFTs.jl</a></p><ul><li><a href="#AbstractNFFTs.AbstractComplexFTPlan"><code>AbstractNFFTs.AbstractComplexFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractFTPlan"><code>AbstractNFFTs.AbstractFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNFCTPlan"><code>AbstractNFFTs.AbstractNFCTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNFFTPlan"><code>AbstractNFFTs.AbstractNFFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNFSTPlan"><code>AbstractNFFTs.AbstractNFSTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractNNFFTPlan"><code>AbstractNFFTs.AbstractNNFFTPlan</code></a></li><li><a href="#AbstractNFFTs.AbstractRealFTPlan"><code>AbstractNFFTs.AbstractRealFTPlan</code></a></li><li><a href="#AbstractNFFTs.accuracyParams-Tuple{}"><code>AbstractNFFTs.accuracyParams</code></a></li><li><a href="#AbstractNFFTs.nfct-Tuple{Any, AbstractArray}"><code>AbstractNFFTs.nfct</code></a></li><li><a href="#AbstractNFFTs.nfct_transpose-Tuple{Any, Any, Any}"><code>AbstractNFFTs.nfct_transpose</code></a></li><li><a href="#AbstractNFFTs.nfft-Tuple{Any, AbstractArray}"><code>AbstractNFFTs.nfft</code></a></li><li><a href="#AbstractNFFTs.nfft_adjoint-Tuple{Any, Any, Any}"><code>AbstractNFFTs.nfft_adjoint</code></a></li><li><a href="#AbstractNFFTs.nfst-Tuple{Any, AbstractArray}"><code>AbstractNFFTs.nfst</code></a></li><li><a href="#AbstractNFFTs.nfst_transpose-Tuple{Any, Any, Any}"><code>AbstractNFFTs.nfst_transpose</code></a></li><li><a href="#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T"><code>AbstractNFFTs.nodes!</code></a></li><li><a href="#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{&lt;:Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}"><code>AbstractNFFTs.plan_nfft</code></a></li><li><a href="#AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_in</code></a></li><li><a href="#AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_out</code></a></li></ul><p><a href="https://github.com/JuliaMath/NFFT.jl">NFFT.jl</a></p><ul><li><a href="#NFFT.precomputeLinInterp-NTuple{5, Any}"><code>NFFT.precomputeLinInterp</code></a></li></ul><p><a href="https://github.com/JuliaMath/NFFT/AbstractNFFTs">NFFTTools.jl</a></p><ul><li><a href="#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><code>NFFTTools.calculateToeplitzKernel</code></a></li><li><a href="#NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T"><code>NFFTTools.calculateToeplitzKernel!</code></a></li><li><a href="#NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}"><code>NFFTTools.convolveToeplitzKernel!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractComplexFTPlan" href="#AbstractNFFTs.AbstractComplexFTPlan"><code>AbstractNFFTs.AbstractComplexFTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractComplexFTPlan{T,D,R}</p><p>Abstract type for either an NFFT plan or an NNFFT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractFTPlan" href="#AbstractNFFTs.AbstractFTPlan"><code>AbstractNFFTs.AbstractFTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractFTPlan{T,D,R}</p><p>Abstract type for any NFFT-like plan (NFFT, NFFT, NFCT, NFST).</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractNFCTPlan" href="#AbstractNFFTs.AbstractNFCTPlan"><code>AbstractNFFTs.AbstractNFCTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractNFCTPlan{T,D,R}</p><p>Abstract type for an NFCT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractNFFTPlan" href="#AbstractNFFTs.AbstractNFFTPlan"><code>AbstractNFFTs.AbstractNFFTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractNFFTPlan{T,D,R}</p><p>Abstract type for an NFFT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractNFSTPlan" href="#AbstractNFFTs.AbstractNFSTPlan"><code>AbstractNFFTs.AbstractNFSTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractNFSTPlan{T,D,R}</p><p>Abstract type for an NFST plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractNNFFTPlan" href="#AbstractNFFTs.AbstractNNFFTPlan"><code>AbstractNFFTs.AbstractNNFFTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractNNFFTPlan{T,D,R}</p><p>Abstract type for an NNFFT plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.AbstractRealFTPlan" href="#AbstractNFFTs.AbstractRealFTPlan"><code>AbstractNFFTs.AbstractRealFTPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractRealFTPlan{T,D,R}</p><p>Abstract type for either an NFCT plan or an NFST plan.</p><ul><li>T is the element type (Float32/Float64)</li><li>D is the number of dimensions of the input array.</li><li>R is the number of dimensions of the output array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.accuracyParams-Tuple{}" href="#AbstractNFFTs.accuracyParams-Tuple{}"><code>AbstractNFFTs.accuracyParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>accuracyParams(; [m, σ, reltol]) -&gt; m, σ, reltol</p><p>Calculate accuracy parameters m, σ, reltol based on either</p><ul><li>reltol</li></ul><p>or</p><ul><li>m, σ</li></ul><p>TODO: Right now, the oversampling parameter is not taken into account, i.e. σ=2.0 is assumed</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nfct-Tuple{Any, AbstractArray}" href="#AbstractNFFTs.nfct-Tuple{Any, AbstractArray}"><code>AbstractNFFTs.nfct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nfft(k, f, rest...; kwargs...)</p><p>calculates the nfft of the array <code>f</code> for the nodes contained in the matrix <code>k</code> The output is a vector of length M=<code>size(nodes,2)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nfct_transpose-Tuple{Any, Any, Any}" href="#AbstractNFFTs.nfct_transpose-Tuple{Any, Any, Any}"><code>AbstractNFFTs.nfct_transpose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nfft_adjoint(k, N, fHat, rest...; kwargs...)</p><p>calculates the adjoint nfft of the vector <code>fHat</code> for the nodes contained in the matrix <code>k</code>. The output is an array of size <code>N</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nfft-Tuple{Any, AbstractArray}" href="#AbstractNFFTs.nfft-Tuple{Any, AbstractArray}"><code>AbstractNFFTs.nfft</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nfft(k, f, rest...; kwargs...)</p><p>calculates the nfft of the array <code>f</code> for the nodes contained in the matrix <code>k</code> The output is a vector of length M=<code>size(nodes,2)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nfft_adjoint-Tuple{Any, Any, Any}" href="#AbstractNFFTs.nfft_adjoint-Tuple{Any, Any, Any}"><code>AbstractNFFTs.nfft_adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nfft_adjoint(k, N, fHat, rest...; kwargs...)</p><p>calculates the adjoint nfft of the vector <code>fHat</code> for the nodes contained in the matrix <code>k</code>. The output is an array of size <code>N</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nfst-Tuple{Any, AbstractArray}" href="#AbstractNFFTs.nfst-Tuple{Any, AbstractArray}"><code>AbstractNFFTs.nfst</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nfft(k, f, rest...; kwargs...)</p><p>calculates the nfft of the array <code>f</code> for the nodes contained in the matrix <code>k</code> The output is a vector of length M=<code>size(nodes,2)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nfst_transpose-Tuple{Any, Any, Any}" href="#AbstractNFFTs.nfst_transpose-Tuple{Any, Any, Any}"><code>AbstractNFFTs.nfst_transpose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>nfft_adjoint(k, N, fHat, rest...; kwargs...)</p><p>calculates the adjoint nfft of the vector <code>fHat</code> for the nodes contained in the matrix <code>k</code>. The output is an array of size <code>N</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T" href="#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T"><code>AbstractNFFTs.nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodes!(p, k) -&gt; p</code></pre><p>Change nodes <code>k</code> in the plan <code>p</code> operation and return the plan.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}" href="#AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size_in(p)</code></pre><p>Size of the input array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has <code>R</code> entries.  Note that this will be the output size for the transposed / adjoint operator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}" href="#AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}"><code>AbstractNFFTs.size_out</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size_out(p)</code></pre><p>Size of the output array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has <code>R</code> entries.  Note that this will be the input size for the transposed / adjoint operator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractComplexFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}" href="#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractComplexFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    *(p, f) -&gt; fHat</code></pre><p>For a <strong>non</strong>-directional <code>D</code> dimensional plan <code>p</code> this calculates the NFFT/NNFFT of a <code>D</code> dimensional array <code>f</code> of size <code>N</code>. <code>fHat</code> is a vector of length <code>M</code>. (<code>M</code> and <code>N</code> are defined in the plan creation)</p><p>For a <strong>directional</strong> <code>D</code> dimensional plan <code>p</code> both <code>f</code> and <code>fHat</code> are <code>D</code> dimensional arrays, and the dimension specified in the plan creation is affected.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractRealFTPlan{T}, AbstractArray{U, D}}} where {T, U, D}" href="#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractRealFTPlan{T}, AbstractArray{U, D}}} where {T, U, D}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    *(p, f) -&gt; fHat</code></pre><p>For a <strong>non</strong>-directional <code>D</code> dimensional plan <code>p</code> this calculates the NFCT/NFST of a <code>D</code> dimensional array <code>f</code> of size <code>N</code>. <code>fHat</code> is a vector of length <code>M</code>. (<code>M</code> and <code>N</code> are defined in the plan creation)</p><p>For a <strong>directional</strong> <code>D</code> dimensional plan <code>p</code> both <code>f</code> and <code>fHat</code> are <code>D</code> dimensional arrays, and the dimension specified in the plan creation is affected.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractFTPlan{T}, AbstractArray}} where T" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractFTPlan{T}, AbstractArray}} where T"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(fHat, p, f) -&gt; fHat</code></pre><p>Inplace NFFT/NFCT/NFST/NNFFT transforming the <code>D</code> dimensional array <code>f</code> to the <code>R</code> dimensional array <code>fHat</code>. The transformation is applied along <code>D-R+1</code> dimensions specified in the plan <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, &lt;:AbstractComplexFTPlan{T}}, AbstractArray}} where T" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, &lt;:AbstractComplexFTPlan{T}}, AbstractArray}} where T"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(f, p, fHat) -&gt; f</code></pre><p>Inplace adjoint NFFT/NNFFT transforming the <code>R</code> dimensional array <code>fHat</code> to the <code>D</code> dimensional array <code>f</code>. The transformation is applied along <code>D-R+1</code> dimensions specified in the plan <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Transpose{T, &lt;:AbstractRealFTPlan{T}}, AbstractArray}} where T" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Transpose{T, &lt;:AbstractRealFTPlan{T}}, AbstractArray}} where T"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(f, p, fHat) -&gt; f</code></pre><p>Inplace transposed NFCT/NFST transforming the <code>R</code> dimensional array <code>fHat</code> to the <code>D</code> dimensional array <code>f</code>. The transformation is applied along <code>D-R+1</code> dimensions specified in the plan <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{&lt;:Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}" href="#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{Type{&lt;:Array}, Matrix{T}, Tuple{Vararg{Int64, D}}, Vararg{Any}}} where {T, D}"><code>AbstractNFFTs.plan_nfft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    plan_nfft(k::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)</code></pre><p>compute a plan for the NFFT of a size-<code>N</code> array at the nodes contained in <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/bb8a95a0f1de254e7acdc0180e5ed91c276478d0/src/NFFT.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFT.precomputeLinInterp-NTuple{5, Any}" href="#NFFT.precomputeLinInterp-NTuple{5, Any}"><code>NFFT.precomputeLinInterp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Precompute the look up table for the window function φ.</p><p>Remarks:</p><ul><li>Only the positive half is computed</li><li>The window is computed for the interval [0, (m)/Ñ]. The reason for the +2 is that we do evaluate the window function outside its interval, since x does not necessary match the sampling points</li><li>The window has K+1 entries and during the index calculation we multiply with the factor K/(m).</li><li>It is very important that K/(m) is an integer since our index calculation exploits this fact. We therefore always use <code>Int(K/(m))</code>instead of <code>K÷(m)</code> since this gives an error while the later variant would silently error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/NFFT.jl/blob/bb8a95a0f1de254e7acdc0180e5ed91c276478d0/src/precomputation.jl#L277-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T" href="#NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T"><code>NFFTTools.calculateToeplitzKernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)</code></pre><p>Calculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in <code>f</code>, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. <a href="https://cds.ismrm.org/ismrm-2001/PDF3/0767.pdf">Wajer, F. T. A. W., and K. P. Pruessmann. &quot;Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.&quot; Proc. Intl. Soc. Mag. Res. Med. 2001.</a>). The type of the kernel <code>f</code> has to be <code>Complex{T}</code>, i.e. the complex of the k-space trajectory&#39;s type; for speed and memory efficiecy, call this function with <code>Float32.(tr)</code>, and set the type of <code>f</code> accordingly.</p><p><strong>Required Arguments</strong></p><ul><li><code>f::Array{T}</code>: Array in which the kernel will be written.</li><li><code>p::AbstractNFFTPlan</code>: NFFTPlan with the same dimensions as <code>tr</code>, which will be overwritten in place.</li><li><code>tr::Matrix{T}</code>: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. <code>tr[i] ∈ [-0.5, 0.5] ∀ i</code>. The matrix has the size <code>2 x Nsamples</code> for 2D imaging with a trajectory length <code>Nsamples</code>, and <code>3 x Nsamples</code> for 3D imaging.</li><li><code>fftplan</code>: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with <code>fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using FFTW

julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(2, 1000) .- 0.5);

julia&gt; p = plan_nfft(trj, (2Nx,2Nx))
NFFTPlan with 1000 sampling points for an input array of size(64, 64) and an output array of size(1000,) with dims 1:2

julia&gt; fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);

julia&gt; λ = Array{ComplexF32}(undef, 2Nx, 2Nx);

julia&gt; calculateToeplitzKernel!(λ, p, trj, fftplan);

julia&gt; y = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(y, λ);
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T" href="#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><code>NFFTTools.calculateToeplitzKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculateToeplitzKernel(shape, tr::Matrix{T}[; m = 4, σ = 2.0, window = :kaiser_bessel, fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])</code></pre><p>Calculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of <code>shape</code>, as the Toeplitz trick requires an oversampling factor of 2 (cf. <a href="https://cds.ismrm.org/ismrm-2001/PDF3/0767.pdf">Wajer, F. T. A. W., and K. P. Pruessmann. &quot;Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.&quot; Proc. Intl. Soc. Mag. Res. Med. 2001.</a>). The type of the kernel is <code>Complex{T}</code>, i.e. the complex of the k-space trajectory&#39;s type; for speed and memory efficiency, call this function with <code>Float32.(tr)</code>, and the kernel will also be <code>Float32</code>.</p><p><strong>Required Arguments</strong></p><ul><li><code>shape::NTuple(Int)</code>: size of the image; e.g. <code>(256, 256)</code> for 2D imaging, or <code>(256,256,128)</code> for 3D imaging</li><li><code>tr::Matrix{T}</code>: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. <code>tr[i] ∈ [-0.5, 0.5] ∀ i</code>. The matrix has the size <code>2 x Nsamples</code> for 2D imaging with a trajectory length <code>Nsamples</code>, and <code>3 x Nsamples</code> for 3D imaging.</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>m::Int</code>: nfft kernel size (used to calculate the Toeplitz kernel); <code>default = 4</code></li><li><code>σ::Number</code>: nfft oversampling factor during the calculation of the Toeplitz kernel; <code>default = 2</code></li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>fftplan</code>: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. <code>default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE)</code>. If this constructor is used many times, it is worth to precompute the plan with <code>plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE)</code> and reuse it.</li><li><code>kwargs</code>: Passed on to <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.plan_fft!"><code>plan_fft!</code></a> via <code>NFFTPlan</code>; can be used to modify the flags <code>flags=FFTW.ESTIMATE, timelimit=Inf</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(2, 1000) .- 0.5);

julia&gt; λ = calculateToeplitzKernel((Nx, Nx), trj)
64×64 Matrix{ComplexF32}:
 -432.209+297.833im    271.68-526.348im  …   3044.35+34.6322im
  990.057-244.569im  -582.825+473.084im      45.7631-87.8965im
  1922.01+223.525im   9248.63-452.04im       3649.78+108.941im
 -402.371-3.37619im   496.815+231.891im      322.646-329.089im
 -482.346-121.534im   559.756-106.981im      155.183+454.0im
   3293.8+194.388im  -3361.43+34.1272im  …   2672.16-526.853im
 -936.331+172.246im   4394.11-400.762im     -1121.04+160.219im
 -135.828+169.448im   3509.17+59.0678im      3883.84-501.913im
  395.143+158.638im   24.4377-387.153im       5731.3+173.827im
  925.902-117.765im    2935.3+346.28im      -1414.12-214.701im
         ⋮                               ⋱
  2239.72-295.883im   490.442+524.399im  …   2028.84-36.5824im
 -1108.11+227.146im   24.7403-455.661im     -549.699+105.319im
  1323.78+110.713im  -321.052+117.802im      651.944-443.178im
 -52.1597+288.0im    -326.042-516.516im       3619.1+44.4651im
  1180.56+73.3666im  -26.1233+155.148im     -869.065-405.832im
  3555.36+649.527im  -198.245-878.042im  …   1198.83-317.062im
 -368.958-177.954im  -360.343+406.469im     -1478.96-154.512im
  4861.29+38.9623im   6082.55-267.478im      2519.09+293.503im
  1022.55-185.869im   177.426+414.384im      3650.56-146.597im

julia&gt; y = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(y, λ)
32×32 Matrix{ComplexF32}:
  177.717-52.0493im   10.6059+20.7185im  …   746.131+330.005im
 -311.858+988.219im  -1216.83-1295.14im      410.732+751.925im
 -1082.27+872.968im   1023.97-1556.45im     -923.699+478.63im
 -999.035-525.161im  -1694.59-658.558im     -521.044+607.005im
 -342.999+1481.82im  -1729.18-2712.81im      56.5212+1394.81im
 -1187.65-1979.55im   1389.67+970.033im  …   2968.93-744.264im
 -666.533+485.511im  -1315.83+409.855im     -610.146+132.258im
  1159.57+64.6059im  -299.169-569.622im      663.802+396.827im
 -795.112-1464.63im   -462.43+2442.77im     -1622.72+1701.27im
 -1047.67+31.5578im  -1127.65-936.043im      474.071+797.911im
         ⋮                               ⋱
  327.345+2191.71im  -904.635+558.786im     -1449.32-276.721im
  -1047.2-71.362im    363.109+567.346im      -1974.0-2348.36im
 -1540.45+1661.77im   1175.75+1279.75im  …   1110.61+653.234im
 -526.832-435.297im  -265.021-2019.08im      68.5607-323.086im
 -1076.52-2719.16im  -477.005+2232.06im      -155.59-1275.66im
  1143.76-735.966im  -380.489+2485.78im      1812.17-261.191im
  1685.44-1243.29im   1911.16-1157.72im     -991.639-42.8214im
  1054.11-1282.41im   66.9358-588.991im  …  -952.238+1026.35im
 -417.276-273.367im  -946.698+1971.77im     -890.339-882.05im
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}" href="#NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any, Any}} where {T, N}"><code>NFFTTools.convolveToeplitzKernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convolveToeplitzKernel!(y::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])</code></pre><p>Convolves the image <code>y</code> with the Toeplitz kernel <code>λ</code> and overwrites <code>y</code> with the result. <code>y</code> is also returned for convenience. As this function is commonly applied many times, it is highly recommended to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.</p><p><strong>Required Arguments</strong></p><ul><li><code>y::Array{T,N}</code>: Input image that will be overwritten with the result. <code>y</code> is a matrix (<code>N=2</code>) for 2D imaging and a 3D tensor (<code>N=3</code>) for 3D imaging. The type of the elements <code>T</code> must match the ones of <code>λ</code>.</li><li><code>λ::Array{T,N}</code>: Toeplitz kernel, which as to be the same type as <code>k</code>, but twice the size due to the required oversampling (cf. <a href="#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T"><code>calculateToeplitzKernel</code></a>).</li></ul><p><strong>Optional, but highly recommended Arguments</strong></p><ul><li><code>fftplan</code>: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with <code>fftplan = plan_fft(λ; flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li><li><code>ifftplan</code>: plan for the oversampled inverse FFT. Calculate, e.g., with <code>ifftplan = plan_ifft(λ; flags=FFTW.MEASURE)</code>, where <code>shape</code> is the size of the reconstructed image.</li><li><code>xOS1</code>: pre-allocated array of the size of <code>λ</code>. Pre-allocate with <code>xOS1 = similar(λ)</code>.</li><li><code>xOS2</code>: pre-allocated array of the size of <code>λ</code>. Pre-allocate with <code>xOS2 = similar(λ)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using FFTW

julia&gt; Nx = 32;

julia&gt; trj = Float32.(rand(2, 1000) .- 0.5);

julia&gt; λ = calculateToeplitzKernel((Nx, Nx), trj);

julia&gt; xOS1 = similar(λ);

julia&gt; xOS2 = similar(λ);

julia&gt; fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);

julia&gt; ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);

julia&gt; y = randn(ComplexF32, Nx, Nx);

julia&gt; convolveToeplitzKernel!(y, λ, fftplan, ifftplan, xOS1, xOS2)
32×32 Matrix{ComplexF32}:
  177.717-52.0493im   10.6059+20.7185im  …   746.131+330.005im
 -311.858+988.219im  -1216.83-1295.14im      410.732+751.925im
 -1082.27+872.968im   1023.97-1556.45im     -923.699+478.63im
 -999.035-525.161im  -1694.59-658.558im     -521.044+607.005im
 -342.999+1481.82im  -1729.18-2712.81im      56.5212+1394.81im
 -1187.65-1979.55im   1389.67+970.033im  …   2968.93-744.264im
 -666.533+485.511im  -1315.83+409.855im     -610.146+132.258im
  1159.57+64.6059im  -299.169-569.622im      663.802+396.827im
 -795.112-1464.63im   -462.43+2442.77im     -1622.72+1701.27im
 -1047.67+31.5578im  -1127.65-936.043im      474.071+797.911im
         ⋮                               ⋱
  327.345+2191.71im  -904.635+558.786im     -1449.32-276.721im
  -1047.2-71.362im    363.109+567.346im      -1974.0-2348.36im
 -1540.45+1661.77im   1175.75+1279.75im  …   1110.61+653.234im
 -526.832-435.297im  -265.021-2019.08im      68.5607-323.086im
 -1076.52-2719.16im  -477.005+2232.06im      -155.59-1275.66im
  1143.76-735.966im  -380.489+2485.78im      1812.17-261.191im
  1685.44-1243.29im   1911.16-1157.72im     -991.639-42.8214im
  1054.11-1282.41im   66.9358-588.991im  …  -952.238+1026.35im
 -417.276-273.367im  -946.698+1971.77im     -890.339-882.05im
</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../abstract/">« AbstractNFFTs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 November 2022 14:39">Wednesday 16 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
