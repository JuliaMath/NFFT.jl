var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of the NFFT.jl package family:\n\nAbstractNFFTs.jl\n\nModules = [AbstractNFFTs]\n\nNFFT.jl\n\nModules = [NFFT]\n\nNFFTTools.jl\n\nModules = [NFFTTools]","category":"section"},{"location":"api/#AbstractNFFTs.AbstractComplexFTPlan","page":"API","title":"AbstractNFFTs.AbstractComplexFTPlan","text":"AbstractComplexFTPlan{T,D,R}\n\nAbstract type for either an NFFT plan or an NNFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractFTPlan","page":"API","title":"AbstractNFFTs.AbstractFTPlan","text":"AbstractFTPlan{T,D,R}\n\nAbstract type for any NFFT-like plan (NFFT, NFFT, NFCT, NFST).\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNFCTPlan","page":"API","title":"AbstractNFFTs.AbstractNFCTPlan","text":"AbstractNFCTPlan{T,D,R}\n\nAbstract type for an NFCT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNFFTPlan","text":"AbstractNFFTPlan{T,D,R}\n\nAbstract type for an NFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNFSTPlan","page":"API","title":"AbstractNFFTs.AbstractNFSTPlan","text":"AbstractNFSTPlan{T,D,R}\n\nAbstract type for an NFST plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractNNFFTPlan","page":"API","title":"AbstractNFFTs.AbstractNNFFTPlan","text":"AbstractNNFFTPlan{T,D,R}\n\nAbstract type for an NNFFT plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.AbstractRealFTPlan","page":"API","title":"AbstractNFFTs.AbstractRealFTPlan","text":"AbstractRealFTPlan{T,D,R}\n\nAbstract type for either an NFCT plan or an NFST plan.\n\nT is the element type (Float32/Float64)\nD is the number of dimensions of the input array.\nR is the number of dimensions of the output array.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractNFFTs.accuracyParams-Tuple{}","page":"API","title":"AbstractNFFTs.accuracyParams","text":"accuracyParams(; [m, σ, reltol]) -> m, σ, reltol\n\nCalculate accuracy parameters m, σ, reltol based on either\n\nreltol\n\nor\n\nm, σ\n\nTODO: Right now, the oversampling parameter is not taken into account, i.e. σ=2.0 is assumed\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.convolve!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}","page":"API","title":"AbstractNFFTs.convolve!","text":"convolve!(p::AbstractNFFTPlan{T,D,R}, g::AbstractArray, fHat::AbstractArray)\n\nOverwrite R-dimensional array fHat (often R=1, and fHat has length p.J) with the result of \"convolution\" (i.e., interpolation) between D-dimensional equispaced input array g (often of size p.N) and the interpolation kernel in NFFT plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.convolve_transpose!-Tuple{AbstractNFFTPlan, AbstractArray, AbstractArray}","page":"API","title":"AbstractNFFTs.convolve_transpose!","text":"convolve_transpose!(p::AbstractNFFTPlan{T,D,R}, fHat::AbstractArray, g::AbstractArray)\n\nAdjoint of convolve! operation, where D-dimensional equispaced array g is overwritten based on the values of R-dimensional input array fHat and the interpolation kernel in NFFT plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.nfct","page":"API","title":"AbstractNFFTs.nfct","text":"nfct(k, f, rest...; kwargs...)\nnfct(backend, k, f, rest...; kwargs...)\n\ncalculates the nfct of the array f for the nodes contained in the matrix k The output is a vector of length M=size(nodes,2).\n\nUses the active AbstractNFFTs backend if no backend argument is provided. Backends can be activated with BackendModule.activate!().\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractNFFTs.nfct_transpose","page":"API","title":"AbstractNFFTs.nfct_transpose","text":"nfct_transpose(k, N, fHat, rest...; kwargs...)\nnfct_transpose(backend, k, N, fHat, rest...; kwargs...)\n\ncalculates the transpose nfct of the vector fHat for the nodes contained in the matrix k. The output is an array of size N.\n\nUses the active AbstractNFFTs backend if no backend argument is provided. Backends can be activated with BackendModule.activate!().\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractNFFTs.nfft","page":"API","title":"AbstractNFFTs.nfft","text":"nfft(k, f, rest...; kwargs...)\nnfft(backend, k, f, rest...; kwargs...)\n\ncalculates the nfft of the array f for the nodes contained in the matrix k The output is a vector of length M=size(nodes,2).\n\nUses the active AbstractNFFTs backend if no backend argument is provided. Backends can be activated with BackendModule.activate!(). Backends can also be set with a scoped value overriding the current active backend within a scope:\n\njulia> NFFT.activate!()\n\njulia> nfft(k, f, rest...; kwargs...) # uses NFFT\n\njulia> with(nfft_backend => NonuniformFFTs.backend()) do\n          nfft(k, f, rest...; kwargs...) # uses NonuniformFFTs\n       end\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractNFFTs.nfft_adjoint","page":"API","title":"AbstractNFFTs.nfft_adjoint","text":"nfft_adjoint(k, N, fHat, rest...; kwargs...)\nnfft_adjoint(backend, k, N, fHat, rest...; kwargs...)\n\ncalculates the adjoint nfft of the vector fHat for the nodes contained in the matrix k. The output is an array of size N.\n\nUses the active AbstractNFFTs backend if no backend argument is provided. Backends can be activated with BackendModule.activate!(). Backends can also be set with a scoped value overriding the current active backend within a scope:\n\njulia> NFFT.activate!()\n\njulia> nfft_adjoint(k, N, fHat, rest...; kwargs...) # uses NFFT\n\njulia> with(nfft_backend => NonuniformFFTs.backend()) do\n          nfft_adjoint(k, N, fHat, rest...; kwargs...) # uses NonuniformFFTs\n       end\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractNFFTs.nfst","page":"API","title":"AbstractNFFTs.nfst","text":"nfst(k, f, rest...; kwargs...)\nnfst(backend, k, f, rest...; kwargs...)\n\ncalculates the nfst of the array f for the nodes contained in the matrix k The output is a vector of length M=size(nodes,2).\n\nUses the active AbstractNFFTs backend if no backend argument is provided. Backends can be activated with BackendModule.activate!().\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractNFFTs.nfst_transpose","page":"API","title":"AbstractNFFTs.nfst_transpose","text":"nfst_transpose(k, N, fHat, rest...; kwargs...)\nnfst_transpose(backend, k, N, fHat, rest...; kwargs...)\n\ncalculates the transpose nfst of the vector fHat for the nodes contained in the matrix k. The output is an array of size N.\n\nUses the active AbstractNFFTs backend if no backend argument is provided. Backends can be activated with BackendModule.activate!().\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractNFFTs.nodes!-Union{Tuple{T}, Tuple{AbstractFTPlan{T}, Matrix{T}}} where T","page":"API","title":"AbstractNFFTs.nodes!","text":"nodes!(p, k) -> p\n\nChange nodes k in the plan p operation and return the plan.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.set_active_backend!-Tuple{Module}","page":"API","title":"AbstractNFFTs.set_active_backend!","text":"set_active_backend!(back::Union{Missing, Module, AbstractNFFTBackend})\n\nSet the default NFFT plan backend. A module back must implement back.backend().\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_in-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_in","text":"size_in(p)\n\nSize of the input array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has R entries.  Note that this will be the output size for the transposed / adjoint operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.size_out-Union{Tuple{AbstractFTPlan{T, D, R}}, Tuple{R}, Tuple{D}, Tuple{T}} where {T, D, R}","page":"API","title":"AbstractNFFTs.size_out","text":"size_out(p)\n\nSize of the output array for the plan p (NFFT/NFCT/NFST/NNFFT).  The returned tuple has R entries.  Note that this will be the input size for the transposed / adjoint operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractComplexFTPlan{T}, AbstractArray{Complex{U}, D}}} where {T, U, D}","page":"API","title":"Base.:*","text":"    *(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFFT/NNFFT of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{D}, Tuple{U}, Tuple{T}, Tuple{AbstractRealFTPlan{T}, AbstractArray{U, D}}} where {T, U, D}","page":"API","title":"Base.:*","text":"    *(p, f) -> fHat\n\nFor a non-directional D dimensional plan p this calculates the NFCT/NFST of a D dimensional array f of size N. fHat is a vector of length M. (M and N are defined in the plan creation)\n\nFor a directional D dimensional plan p both f and fHat are D dimensional arrays, and the dimension specified in the plan creation is affected.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, AbstractFTPlan{T}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(fHat, p, f) -> fHat\n\nInplace NFFT/NFCT/NFST/NNFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Adjoint{Complex{T}, <:AbstractComplexFTPlan{T}}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(f, p, fHat) -> f\n\nInplace adjoint NFFT/NNFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{AbstractArray, LinearAlgebra.Transpose{T, <:AbstractRealFTPlan{T}}, AbstractArray}} where T","page":"API","title":"LinearAlgebra.mul!","text":"mul!(f, p, fHat) -> f\n\nInplace transposed NFCT/NFST transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractNFFTs.plan_nfft-Union{Tuple{D}, Tuple{T}, Tuple{NFFTBackend, Type{<:Array}, Matrix{T}, NTuple{D, Int64}, Vararg{Any}}} where {T, D}","page":"API","title":"AbstractNFFTs.plan_nfft","text":"NFFT.plan_nfft(k::Matrix{T}, N::NTuple{D,Int}, rest...;  kargs...)\n\ncompute a plan for the NFFT of a size-N array at the nodes contained in k.\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFT.precomputeLinInterp-NTuple{5, Any}","page":"API","title":"NFFT.precomputeLinInterp","text":"Precompute the look up table for the window function φ.\n\nRemarks:\n\nOnly the positive half is computed\nThe window is computed for the interval [0, (m)/Ñ]. The reason for the +2 is that we do evaluate the window function outside its interval, since x does not necessary match the sampling points\nThe window has K+1 entries and during the index calculation we multiply with the factor K/(m).\nIt is very important that K/(m) is an integer since our index calculation exploits this fact. We therefore always use Int(K/(m))instead of K÷(m) since this gives an error while the later variant would silently error.\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFTTools.calculateToeplitzKernel!-Union{Tuple{T}, Tuple{Array{Complex{T}}, AbstractNFFTPlan{T}, Matrix{T}, Any}} where T","page":"API","title":"NFFTTools.calculateToeplitzKernel!","text":"calculateToeplitzKernel!(f::Array{Complex{T}}, p::AbstractNFFTPlan, tr::Matrix{T}, fftplan)\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure and writes it in-place in f, which has to be twice the size of the desired image matrix, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel f has to be Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiecy, call this function with Float32.(tr), and set the type of f accordingly.\n\nRequired Arguments\n\nf::Array{T}: Array in which the kernel will be written.\np::AbstractNFFTPlan: NFFTPlan with the same dimensions as tr, which will be overwritten in place.\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\nfftplan: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\n\nExamples\n\njulia> using NFFTTools.FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(rng, 2, 1000) .- 0.5);\n\njulia> p = plan_nfft(trj, (2Nx,2Nx))\nNFFTPlan with 1000 sampling points for an input array of size(64, 64) and an output array of size(1000,) with dims 1:2\n\njulia> fftplan = plan_fft(zeros(ComplexF32, (2Nx,2Nx)); flags=FFTW.MEASURE);\n\njulia> λ = Array{ComplexF32}(undef, 2Nx, 2Nx);\n\njulia> calculateToeplitzKernel!(λ, p, trj, fftplan);\n\njulia> y = randn(rng, ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(y, λ);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFTTools.calculateToeplitzKernel-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T","page":"API","title":"NFFTTools.calculateToeplitzKernel","text":"calculateToeplitzKernel(shape, tr::Matrix{T}[; m = 4, σ = 2.0, window = :kaiser_bessel, fftplan = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE), kwargs...])\n\nCalculate the kernel for an implementation of the Gram matrix that utilizes its Toeplitz structure. The output is an array of twice the size of shape, as the Toeplitz trick requires an oversampling factor of 2 (cf. Wajer, F. T. A. W., and K. P. Pruessmann. \"Major speedup of reconstruction for sensitivity encoding with arbitrary trajectories.\" Proc. Intl. Soc. Mag. Res. Med. 2001.). The type of the kernel is Complex{T}, i.e. the complex of the k-space trajectory's type; for speed and memory efficiency, call this function with Float32.(tr), and the kernel will also be Float32.\n\nRequired Arguments\n\nshape::NTuple(Int): size of the image; e.g. (256, 256) for 2D imaging, or (256,256,128) for 3D imaging\ntr::Matrix{T}: non-Cartesian k-space trajectory in units revolutions/voxel, i.e. tr[i] ∈ [-0.5, 0.5] ∀ i. The matrix has the size 2 x Nsamples for 2D imaging with a trajectory length Nsamples, and 3 x Nsamples for 3D imaging.\n\nOptional Arguments:\n\nm::Int: nfft kernel size (used to calculate the Toeplitz kernel); default = 4\nσ::Number: nfft oversampling factor during the calculation of the Toeplitz kernel; default = 2\n\nKeyword Arguments:\n\nfftplan: plan for the final FFT of the kernel from image to k-space. Therefore, it has to have twice the size of the original image. default = plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.ESTIMATE). If this constructor is used many times, it is worth to precompute the plan with plan_fft(zeros(Complex{T}, 2 .* shape); flags=FFTW.MEASURE) and reuse it.\nkwargs: Passed on to plan_fft! via NFFTPlan; can be used to modify the flags flags=FFTW.ESTIMATE, timelimit=Inf.\n\nExamples\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(rng, 2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj)\n64×64 Matrix{ComplexF32}:\n -1528.64-170.936im  -622.032+56.4626im  …   2570.27-41.6055im\n   3685.0+276.482im   2282.33-162.009im      2142.57-63.9413im\n -125.272-342.877im   819.441+228.404im      4293.36+130.336im\n  940.796+31.5781im  -852.504+82.8948im      2681.78+180.963im\n  445.039-252.226im  -1552.49+137.753im     -2037.24+39.6851im\n  493.161+173.293im   664.534-58.8202im  …   1463.51+39.2481im\n  332.265-180.768im   -2650.6+66.2951im     -2778.37-31.7731im\n  2079.48-127.658im   4891.04+242.131im      3734.65+340.2im\n  120.836-265.792im   10931.5+151.319im      4528.12+53.2504im\n -1247.63+356.045im  -198.919-241.572im       46.912-143.504im\n         ⋮                               ⋱\n -340.961+142.965im   6010.83-28.4918im  …   2779.73+69.5765im\n -1826.62-161.638im   1103.42+47.1655im      2479.09-50.9026im\n  2267.81+80.567im    1044.85+33.9058im      2327.04+131.974im\n  1467.38-89.7949im   3410.85-24.6781im      1980.45-122.746im\n   167.15+342.008im   1476.08-227.535im      2143.39-129.466im\n -724.138-204.324im   1686.02+89.8505im  …  -244.694-8.21769im\n  237.304-84.753im   -1067.19+199.226im     -128.015+297.294im\n  1848.84+50.5511im   1926.33-165.024im     -937.614-263.092im\n  1912.83-152.94im    741.748+267.413im     -343.194+365.481im\n\njulia> y = randn(ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(y, λ)\n32×32 Matrix{ComplexF32}:\n -718.038+2035.75im  -1771.79+191.592im  …  -1087.95+260.256im\n -472.432+473.74im   -1894.01+1138.22im     -295.522-647.603im\n  139.463+1137.28im    184.53+228.995im      788.817-355.36im\n  2966.54-1767.96im   255.169+590.332im      341.963+94.7469im\n  -594.67-538.93im    180.487-566.905im      69.4853+481.47im\n -1004.42-111.931im   2439.67-323.525im  …   -448.47+1459.57im\n -341.784+49.591im   -268.101-750.184im      1309.23-108.091im\n  189.394+638.56im   -821.709+121.441im      100.152-914.375im\n -192.401-702.179im  -1564.33-536.778im       1448.4-971.389im\n  492.427-1121.14im  -3270.99+249.791im     -245.744+1659.15im\n         ⋮                               ⋱\n  1309.34+98.404im    73.0096-1181.38im      557.821-1096.24im\n  907.312+129.232im  -44.5222+1075.8im      -879.056-180.416im\n -1020.87-671.83im   -1019.44-778.932im  …  -878.007+2165.44im\n -392.366-745.654im  -279.611-1023.18im      804.285-51.4734im\n -1139.86-549.792im  -1135.39+1236.09im      538.431+1891.79im\n  391.965+974.582im  -1445.21-1113.64im      1172.98+116.43im\n -870.086-1002.25im   1100.69+846.779im     -377.282-602.989im\n  928.376-163.128im  -1009.71+1075.25im  …  -444.653-140.651im\n  268.106+635.919im   919.454-170.406im      233.847-1058.75im\n\n\n\n\n\n\n","category":"method"},{"location":"api/#NFFTTools.convolveToeplitzKernel!-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}, Tuple{Array{T, N}, Array{T, N}, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Array{T, N}, Vararg{Any, 4}}} where {T, N}","page":"API","title":"NFFTTools.convolveToeplitzKernel!","text":"convolveToeplitzKernel!(y::Array{T,N}, λ::Array{T,N}[, fftplan = plan_fft(λ; flags=FFTW.ESTIMATE), ifftplan = plan_ifft(λ; flags=FFTW.ESTIMATE), xOS1 = similar(λ), xOS2 = similar(λ)])\n\nConvolves the image y with the Toeplitz kernel λ and overwrites y with the result. y is also returned for convenience. As this function is commonly applied many times, it is highly recommended to pre-allocate / pre-compute all optional arguments. By doing so, this entire function is non-allocating.\n\nRequired Arguments\n\ny::Array{T,N}: Input image that will be overwritten with the result. y is a matrix (N=2) for 2D imaging and a 3D tensor (N=3) for 3D imaging. The type of the elements T must match the ones of λ.\nλ::Array{T,N}: Toeplitz kernel, which as to be the same type as k, but twice the size due to the required oversampling (cf. calculateToeplitzKernel).\n\nOptional, but highly recommended Arguments\n\nfftplan: plan for the oversampled FFT, i.e. it has to have twice the size of the original image. Calculate, e.g., with fftplan = plan_fft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nifftplan: plan for the oversampled inverse FFT. Calculate, e.g., with ifftplan = plan_ifft(λ; flags=FFTW.MEASURE), where shape is the size of the reconstructed image.\nxOS1: pre-allocated array of the size of λ. Pre-allocate with xOS1 = similar(λ).\nxOS2: pre-allocated array of the size of λ. Pre-allocate with xOS2 = similar(λ).\n\nExamples\n\njulia> using NFFTTools.FFTW\n\njulia> Nx = 32;\n\njulia> trj = Float32.(rand(rng, 2, 1000) .- 0.5);\n\njulia> λ = calculateToeplitzKernel((Nx, Nx), trj);\n\njulia> xOS1 = similar(λ);\n\njulia> xOS2 = similar(λ);\n\njulia> fftplan = plan_fft(xOS1; flags=FFTW.MEASURE);\n\njulia> ifftplan = plan_ifft(xOS1; flags=FFTW.MEASURE);\n\njulia> y = randn(rng, ComplexF32, Nx, Nx);\n\njulia> convolveToeplitzKernel!(y, λ, fftplan, ifftplan, xOS1, xOS2)\n32×32 Matrix{ComplexF32}:\n  -783.38-230.709im  -41.2715-196.622im  …   1051.97+1655.19im\n  306.303+931.416im  -212.223-960.781im     -270.816-4.68915im\n  1018.79+974.724im   1204.28-1286.06im      398.504+298.177im\n   138.68+346.405im   225.016-586.742im      397.565-205.818im\n  402.152+725.267im   731.119-307.097im      810.773-244.329im\n  680.202-682.887im  -7.59145-254.964im  …  -1219.87-1119.43im\n -64.0526-909.241im   61.5645+1199.98im       253.19-630.097im\n -835.246-993.775im  -1561.78+969.924im     -7.08272+1755.43im\n   163.15-212.155im   1282.88+250.916im      819.356+1184.85im\n  71.7218-933.054im   772.495-39.3827im      495.359+2949.17im\n         ⋮                               ⋱\n -499.452-192.12im   -589.649+1561.74im      1544.92+126.5im\n -347.838+791.432im  -112.339+269.57im      -1068.77+452.493im\n  1861.73-494.369im   416.406+499.465im  …  -1856.07-211.381im\n   176.94+984.977im   874.282+41.8216im     -1717.71+1169.11im\n  516.513+270.692im   531.069+1907.76im     -697.752+42.6127im\n  -65.358-411.893im  -1299.86-868.781im     -285.473-1803.2im\n -15.1395+439.582im   84.4428+2026.06im      13.6334+24.6603im\n -1146.97+1632.87im  -208.162+1114.2im   …   -295.39+854.479im\n  502.986+591.013im  -1013.11+97.8801im      617.683+17.4492im\n\n\n\n\n\n\n","category":"method"},{"location":"performance/#Accuracy-and-Performance","page":"Performance","title":"Accuracy and Performance","text":"On this page, the accuracy and the performance of NFFT.jl are investigated. For comparison we use the C library NFFT3 and the C++ library FINUFFT.  The parameters for the benchmark are \n\nbmN_text1D=(512*512) bmN_text2D=(512512) bmN_text3D=(646464)\nJ= vert bmN vert\nm=3 dots 8\nsigma = 2\nPOLYNOMIAL and TENSOR precomputation\n1 thread\nrandom nodes\n\nAll benchmarks are performed with @belapsed from BenchmarkTools.jl which takes the minimum of several runs (120 s upper benchmark time). The benchmark is run on a computer with 2 AMD EPYC 7702 CPUs running at 2.0 GHz (256 cores in total) and a main memory of 1024 GB. The benchmark suite is described here.\n\nThe results for D=1dots3 are shown in the following graphic illustrating the accuracy (x-axis) versus the performance (y-axis) for various m. \n\n(Image: Performance vs Accurracy 1D)\n\nThe results show that NFFT.jl is one of the fastest NFFT libraries. One can chose between shorter precomputation time using POLYNOMIAL precomputation or faster transforms using TENSOR precomputation.","category":"section"},{"location":"abstract/#Abstract-Interface-for-NFFTs","page":"AbstractNFFTs","title":"Abstract Interface for NFFTs","text":"The package AbstractNFFTs provides the abstract interface for NFFT implementations. Defining an abstract interface has the advantage that different implementations can be used and exchanging requires  only small effort.\n\nAn overview about the current packages and their dependencies is shown in the following package tree:\n\n(Image: NFFT.jl package family structure)\n\nnote: Note\nIf you are not an expert user, you likely do not require different NFFT implementations and we therefore recommend to just use NFFT.jl and not worry about the abstract interface. ","category":"section"},{"location":"abstract/#Implementations","page":"AbstractNFFTs","title":"Implementations","text":"Currently, there are four implementations of the AbstractNFFTs interface:\n\nNFFT.jl: This is the reference implementation running on the CPU and with configurations on the GPU.\nNFFT3.jl: In the Wrapper directory of NFFT.jl there is a wrapper around the NFFT3.jl package following the  AbstractNFFTs interface. NFFT3.jl is itself a wrapper around the high performance C library NFFT3.\nFINUFFT.jl: In the Wrapper directory of NFFT.jl there is a wrapper around the FINUFFT.jl package. FINUFFT.jl is itself a wrapper around the high performance C++ library FINUFFT.\nNonuniformFFTs.jl: Pure Julia package written with generic and fast GPU kernels written with KernelAbstractions.jl.\n\nnote: Note\nRight now one needs to install NFFT.jl and manually include the wrapper files. In the future we hope to integrate the wrappers in NFFT3.jl and FINUFFT.jl directly such that it is much more convenient to switch libraries.\n\nIt's possible to change between different implementation backends. Each backend has to implement a backend type, which by convention can be accessed via for example NFFT.backend(). There are several ways to activate a backend:\n\n# Actively setting a backend:\nAbstractNFFTs.set_active_backend!(NFFT.backend())\n# Activating a backend:\nNFFT.activate!()\n# and creating a new dynamic scope which uses a different backend:\nwith(nfft_backend => NonuniformFFTs.backend()) do\n    # Uses NonuniformFFTs as implementation backend\nend\n# It's also possible to directly pass backends to functions:\nnfft(NonuniformFFTs.backend(), ...)","category":"section"},{"location":"abstract/#Interface","page":"AbstractNFFTs","title":"Interface","text":"An NFFT implementation needs to define a new type that is a subtype of AbstractNFFTPlan{T,D,R}. Here\n\nT is the real-valued element type of the nodes, i.e. a transform operating on Complex{Float64} values and Float64 nodes uses the type T=Float64.\nD is the size of the input vector\nR is the size of the output vector. Usually this will be R=1 unless a directional NFFT is implemented.\n\nFor instance the NFFTPlan is defined like this\n\nmutable struct NFFTPlan{T,D,R} <: AbstractNFFTPlan{T,D,R} \n  ...\nend\n\nFurthermore, a package needs to implement its own backend type to dispatch on\n\nstruct MyBackend <: AbstractNFFTBackend\n\nand it should allow a user to activate the package, which by convention can be done with (unexported) functions:\n\nactivate!() = AbstractNFFTs.set_active_backend!(MyBackend())\nbackend() = MyBackend()\n\nIn addition to the plan and backend, the following functions need to be implemented: \n\nsize_out(p)\nsize_out(p)\nmul!(fHat, p, f) -> fHat\nmul!(f, p::Adjoint{Complex{T},<:AbstractNFFTPlan{T}}, fHat) -> f\nnodes!(p, k) -> p\n\nAll these functions are exported from AbstractNFFTs and we recommend to implement them using the explicit AbstractNFFTs. prefix:\n\nfunction AbstractNFFTs.size_out(p:MyNFFTPlan)\n ...\nend\n\nWe next outline all of the aforementioned functions and describe their behavior:\n\n    size_in(p)\n\nSize of the input array for an NFFT operation. The returned tuple has D entries.  Note that this will be the output array for an adjoint NFFT.\n\n    size_out(p)\n\nSize of the output array for an NFFT operation. The returned tuple has R entries.  Note that this will be the input array for an adjoint NFFT.\n\n    mul!(fHat, p, f) -> fHat\n\nInplace NFFT transforming the D dimensional array f to the R dimensional array fHat. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n    mul!(f, p::Adjoint{Complex{T},<:AbstractNFFTPlan{T}}, fHat) -> f\n\nInplace adjoint NFFT transforming the R dimensional array fHat to the D dimensional array f. The transformation is applied along D-R+1 dimensions specified in the plan p. Both f and fHat must be complex arrays of element type Complex{T}.\n\n    nodes!(p, k)\n\nExchange the nodes k in the plan p and return the plan. The implementation of this function is optional.","category":"section"},{"location":"abstract/#Plan-Interface","page":"AbstractNFFTs","title":"Plan Interface","text":"The constructor for a plan also has a defined interface. It should be implemented in this way:\n\nfunction MyNFFTPlan(k::Matrix{T}, N::NTuple{D,Int}; kwargs...) where {T,D}\n  ...\nend\n\nAll parameters are put into keyword arguments that have to match as well. We describe the keyword arguments in more detail in the overview page. Using the same plan interface allows to load several NFFT libraries simultaneously and exchange the constructor dynamically by storing the constructor in a function object. This is how the unit tests of NFFT.jl run.\n\nAdditionally, to the type-specific constructor one can provide the factory\n\nplan_nfft(b::MyBackend, Q::Type, k::Matrix{T}, N::NTuple{D,Int}; kargs...) where {D}\n\nwhere Q is the Array type, e.g. Array. The reason to require the array type is, that this allows for GPU implementations, which would use for instance CuArray here.\n\nThe package AbstractNFFTs provides a convenient constructor\n\nplan_nfft(b::MyBackend, k::Matrix{T}, N::NTuple{D,Int}; kargs...) where {D}\n\ndefaulting to the Array type.","category":"section"},{"location":"abstract/#Derived-Interface","page":"AbstractNFFTs","title":"Derived Interface","text":"Based on the core low-level interface that an AbstractNFFTPlan needs to provide, the package AbstractNFFT.jl also provides high-level functions like *, nfft, and nfft_adjoint, which internally use the low-level interface. Thus, the implementation of high-level function is shared among all AbstractNFFT.jl implementations.","category":"section"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Getting-Started","page":"Overview","title":"Getting Started","text":"Basic usage of NFFT.jl is shown in the following example for 1D:\n\nusing NFFT\n\nJ, N = 8, 16\nk = range(-0.4, stop=0.4, length=J)  # nodes at which the NFFT is evaluated\nf = randn(rng, ComplexF64, J)             # data to be transformed\np = plan_nfft(k, N, reltol=1e-9)     # create plan\nfHat = adjoint(p) * f                # calculate adjoint NFFT\ny = p * fHat                         # calculate forward NFFT\n\nIn the same way the 2D NFFT can be applied:\n\nJ, N = 16, 32\nk = rand(rng, 2, J) .- 0.5\nf = randn(rng, ComplexF64, J)\np = plan_nfft(k, (N,N), reltol=1e-9)\nfHat = adjoint(p) * f\ny = p * fHat\n\nCurrently, the eltype of the arguments f and fHat must be compatible with that of the sampling nodes k used in the plan_nfft call. For example, if one wants to use Float32 types to save memory, one can create the plan like this:\n\nk = Float32.(LinRange(-0.5,0.5,64))\np = plan_nfft(k, N)\n\nThe plan will then internally use Float32 types. The signals f and fHat then need to have the eltype Complex{Float32} or equivalently ComplexF32. Otherwise there will be error messages.\n\nIn the previous example, the output vector was allocated within the * method. To avoid this allocation one can use the interface\n\nmul!(fHat, p, f)\nmul!(y, adjoint(p), fHat)\n\nwhich allows to pass the output vector as the first argument.\n\nOne can also perform NFFT computations directly without first creating a plan:\n\nfHat = nfft(k, f)\ny = nfft_adjoint(k, N, fHat)\n\nThese forms are more forgiving about the types of the input arguments. The versions based on a plan are more optimized for repeated use with the same sampling nodes k.  Note that nfft_adjoint requires the extra argument N since this cannot be derived from the input vector as can be done for nfft. \n\nnote: Note\nThe constructor plan_nfft is meant to be a generic factory function that can be implemented in different packages. If you want to use a concrete constructor of NFFT.jl use NFFTPlan instead. ","category":"section"},{"location":"overview/#Parameters","page":"Overview","title":"Parameters","text":"The NFFT has the several parameters that can be passed as a keyword argument to the constructor or the nfft and the nfft_adjoint function.\n\nParameter Description Example Values\nreltol Relative tolerance that the NFFT achieves. reltol =10^-9\nm Kernel size parameter. The convolution matrix has 2m+1 non-zero entries around each sampling node in each dimension. m in 2dots8\nσ Oversampling factor. The inner FFT is of size σN σ in 125 20\nwindow Convolution window hatvarphi :kaiser_bessel\nprecompute Flag indicating the precomputation strategy for the convolution matrix TENSOR\nblocking Flag block partitioning should be used to speed up computation true\nsortNodes Flag if the nodes should be sorted in a lexicographic way false\nstoreDeconvolutionIdx Flag if the deconvolve indices should be stored. Currently this option is necessary on the GPU true\nfftflags flags passed to the inner AbstractFFT as flags. This can for instance be FFTW.MEASURE in order to optimize the inner FFT FFTW.ESTIMATE\n\nIn practice the default values are properly chosen and there is in most cases no need to change them.  The only parameter you sometimes need to care about are the accuracy parameters reltol, m,\\sigma and the fftflags.","category":"section"},{"location":"overview/#Accuracy","page":"Overview","title":"Accuracy","text":"On a high-level it is possible to set the accuracy using the parameter reltol. It will automatically set the low-level parameters m and \\sigma. You only need to change the later if you run into memory issues. It is important that you change only reltol or the pair m,\\sigma.\n\nThe relation between reltol, m, and σ depends on the window function and the NFFT implementation. We use the formula\n\nw = 2m + 1 = leftlceil textlog_10 frac1textreltol rightrceil + 1\n\nwhich was verified for σ and the default window function. If you change the window function, you should use the parameter m, and σ instead of reltol.","category":"section"},{"location":"overview/#Window-Functions","page":"Overview","title":"Window Functions","text":"It is possible to change the internal window function hatvarphi. Available are \n\n:gauss\n:spline\n:kaiser_bessel_rev\n:kaiser_bessel \n:cosh_type\n\nand one can easily add more by extending the windowFunctions.jl file in Github.\n\nHowever, the possibility of changing the window function is only important for NFFT researcher and not for NFFT users. Right now :kaiser_bessel provides the best accuracy and thus there is no reason to change the parameter window to something different.","category":"section"},{"location":"overview/#Precomputation","page":"Overview","title":"Precomputation","text":"There are different precomputation strategies available:\n\nValue Description\nNFFT.POLYNOMIAL This option approximates the window function by a polynomial with high degree and evaluates the polynomial during the actual convolution.\nNFFT.LINEAR This option uses a look-up table to first sample the window function and later use linear interpolation during the actual convolution.\nNFFT.FULL This option precomputes the entire convolution matrix and stores it as a SparseMatrixCSC. This option requires more memory and the longest precomputation time. This allows simple GPU implementations like realized in CuNFFT.\nNFFT.TENSOR This option calculates the window on demand but exploits the tensor product structure for multi-dimensional plans.\n\nAgain you don't need to change this parameter since the default NFFT.POLYNOMIAL is a good choice in most situations. You may want to use NFFT.TENSOR if you are applying the same transform multiple times since it is a little bit faster than NFFT.POLYNOMIAL but has a higher pre-computation time.","category":"section"},{"location":"overview/#Block-Partitioning","page":"Overview","title":"Block Partitioning","text":"Internally NFFT can use block partitioning to speedup computation. It helps in two ways\n\nIt helps improving the memory efficiency by grouping sampling points together which allows for better use of CPU caches.\nBlock partitioning is a mandatory to enable multi-threading in the adjoint NFFT, which would otherwise not be possible because of a data dependency.\n\nWe enable block partitioning by default since it helps also in the single-threaded case and thus, there usually is no reason to switch it off.","category":"section"},{"location":"overview/#Multi-Threading","page":"Overview","title":"Multi-Threading","text":"Most parts of NFFT are multi-threaded when running on the CPU. To this end, start Julia with the option\n\njulia -t T\n\nwhere T it the number of desired threads. NFFT.jl will use all threads that are specified. ","category":"section"},{"location":"overview/#Directional","page":"Overview","title":"Directional","text":"There are special methods for computing 1D NFFT's for each 1D slice along a particular dimension of a higher dimensional array.\n\nJ = 11\n\ny = rand(rng, J) .- 0.5\nN = (16,20)\np1 = plan_nfft(y, N, dims=1)\nf = randn(rng, ComplexF64, N)\nfHat = p1 * f\n\nHere size(f) = (16,20) and size(fHat) = (11,20) since we compute an NFFT along the first dimension. To compute the NFFT along the second dimension\n\np2 = plan_nfft(y, N, dims=2)\nfHat = p2 * f\n\nNow size(fHat) = (16,11).","category":"section"},{"location":"background/#Mathematical-Background","page":"Background","title":"Mathematical Background","text":"On this page we give a brief overview of the mathematical background of the NFFT. For a full background including a derivation of the NFFT we refer to the NFFT.jl paper.\n\nnote: Note\nIn the literature the NFFT has different names. Often it is called NUFFT, and in the MRI context gridding.","category":"section"},{"location":"background/#NDFT","page":"Background","title":"NDFT","text":"We first define the non-equidistant discrete Fourier transform (NDFT) that corresponds to the ordinary DFT. Let bmN in mathbbN^D with D in mathbbN be the size of the D-dimensional  equidistantly sampled signal bmf = (f_bmn)_bmn in I_bmN. bmf can for instance be a time or spatial domain signal. The signal is indexed using the multi-index set\n\nI_bmN = mathbbZ^D cap prod_d=1^D left-fracN_d2fracN_d2right)\n\nand thus represents a regular sampling that would also be considered when applying an ordinary DFT. The NDFT now maps from the equidistant domain to the non-equidistant domain and is defined as\n\n  \thatf_j = sum_ bmn in I_bmN f_bmn  mathrme^-2pimathrmibmncdotbmk_j quad j=1dots J qquad textit(equidistant to non-equidistant)\n\nwhere the bmk_j in mathbbT^D j=1dots J with J in mathbbN are the nonequidistant sampling nodes, mathbbT = 1212) is the torus and hatbmf is the D-dimensional frequency domain signal.\n\nThe direct NDFT has an associated adjoint that can be formulated as\n\n\ty_bmn = sum_j = 1^J hatf_j  mathrme^2 pi mathrmi  bmn cdot bmk_j bmn in I_bmN qquad textit(non-equidistant to equidistant)\n\nWe note that in general the adjoint NDFT is not the inverse NDFT. \n\nnote: Note\nThe indices in the index set I_bmN are centered around zero, which is the common definition of the NDFT. In contrast the indices of the DFT usually run from 0dotsN_d-1. This means that an fftshift needs to be applied to change from one representation to the other.\n\nnote: Note\nInstead of the direct/adjoint NDFT terminology, there is an alternative classification that consists of three types. Type 1 corresponds to the adjoint NDFT, type 2 corresponds to the direct NDFT and type 3 corresponds to the NNDFT which has non-equidistant samples in both domains. Further information on this alternative formulation can be found here. ","category":"section"},{"location":"background/#Matrix-Vector-Notation","page":"Background","title":"Matrix-Vector Notation","text":"The NDFT can be written as\n\n hatbmf = bmA bmf\n\nwhere\n\nbeginaligned\n hatbmf = left( hatf_j right)_j=1^J in mathbbC^J \n bmf = left( f_bmn right)_bmn in I_mathbfN in mathbbC^bmN\n  bmA =  left( mathrme^-2 pi mathrmi  bmn cdot bmk_j right)_j=1dotsJ bmn in I_mathbfN in mathbbC^J times bmN\nendaligned\n\nand where bmN = textprod(bmN). The adjoint can then be written as\n\n bmy = bmA^mathsfH  hatbmf\n\nwhere bmy in mathbbC^bmN.","category":"section"},{"location":"background/#NFFT","page":"Background","title":"NFFT","text":"The NFFT is an approximative algorithm that realizes the NDFT in just mathcal O(bmN log bmN + J) steps. This is at the same level as the ordinary FFT with the exception of the additional linear term J, which is unavoidable since all nodes need to be touched as least once.\n\nThe NFFT has two important parameters that influence its accuracy:\n\nthe window size parameter m in mathbbN\nthe oversampling factor sigma in mathbbR with sigma  1\n\nFrom the latter we can derive tildebmN = sigma bmN in (2mathbbN)^D. As the definition indicates, the oversampling factor sigma is usually adjusted such that tildebmN consists of even integers.\n\nThe NFFT now approximates bmA by the product of three matrices\n\nbmA approx bmB bmF bmD\n\nwhere \n\nbmF in mathbbC^tildemathbfN times tildemathbfN is the regular DFT matrix.\nbmD in mathbbC^tildemathbfN times mathbfN is a diagonal matrix that additionally includes zero filling and the fftshift. We call this the deconvolution matrix.\nbmB in mathbbC^M times tildemathbfN is a sparse matrix implementing the discrete convolution with a window function hatvarphi. We call this the convolution matrix.\n\nThe NFFT is based on the convolution theorem. It applies a convolution in the non-equidistant domain, which is evaluated at equidistant sampling nodes. This convolution is then corrected in the equidistant domain by division with the inverse Fourier transform hatvarphi. \n\nThe adjoint NFFT matrix approximates bmA^mathsfH by\n\nbmA^mathsfH approx bmD^mathsfH bmF^mathsfH  bmB^mathsfH \n\nImplementation-wise, the matrix-vector notation illustrates that the NFFT consists of three independent steps that are performed successively. \n\nThe multiplication with bmD is a scalar multiplication with the input-vector plus the shifting of data, which can be done inplace.\nThe FFT can be done with a high-performance FFT library such as the FFTW.\nThe multiplication with bmB needs to run only over a subset of the indices and is the most challenging step.\n\nSince in practice the multiplication with bmB is also the most expensive step, an NFFT library needs to pay special attention to optimizing it appropriately.","category":"section"},{"location":"background/#Directional-NFFT","page":"Background","title":"Directional NFFT","text":"In many cases one not just needs to apply a single NFFT but needs to apply many on different data. This leads us to the directional NFFT. The directional NFFT is defined as\n\n  \tf_bmljbmr = sum_ bmn in I_bmN_textsub hatf_bmlbmnbmr  mathrme^-2pimathrmibmncdotbmk_j\n\nwhere now (bml bmk bmr) in I_mathbfN and I_bmN_textsub is a subset of I_bmN. The transform thus maps a D-dimensional tensor hatf_bmlbmnbmr to an R-dimensional tensor f_bmljbmr. bmN_textsub is thus a vector of length D-R+1. The indices bml and bmr can also have length zero. Thus, for R=1, the conventional NFFT arises as a special case of the directional NFFT.\n\nnote: Note\nThe directional NFFT can also be considered to be a slicing of a tensor with subsequent application of a regular NFFT. But the aforementioned formulation can be used to implement a much more efficient algorithm than can be achieved with slicing.","category":"section"},{"location":"#NFFT.jl","page":"Home","title":"NFFT.jl","text":"Julia package for the Non-equidistant Fast Fourier Transform","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"This package provides a Julia implementation of the Non-equidistant Fast Fourier Transform (NFFT). For a detailed introduction into the NFFT and its application please have a look at the software paper on the NFFT.jl. Further resources are nfft.org and finufft.readthedocs.io.\n\nThe NFFT is a fast implementation of the Non-equidistant Discrete Fourier Transform (NDFT) that is basically a Discrete Fourier Transform (DFT) with non-equidistant sampling nodes in either Fourier or time/space domain. In contrast to the Fast Fourier Transform (FFT), the NFFT is an approximative algorithm whereas the accuracy can be controlled by two parameters: the window width parameter m and the oversampling factor σ.\n\nThe NFFT.jl project serves two different purposes:\n\nProvide a package AbstractNFFTs.jl that allows to use any NFFT Julia package such as NFFT3.jl or FINUFFT.jl using the same interface\nProvide a high-performance, multi-threaded reference implementation in pure Julia. This is realized in the Julia package NFFT.jl.\n\nThe term NFFT.jl thus may either mean the entire Github project consisting of several packages or the concrete reference implementation.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Start julia and open the package mode by entering ]. Then enter\n\nadd NFFT\n\nThis will install the packages NFFT.jl and all its dependencies. Most importantly it installs the abstract interface package AbstractNFFTs.jl, which NFFT.jl implements.\n\nAdditional NFFT related tools can be obtained by adding the package NFFTTools.jl. If you need support for CUDA or other GPU backends, you only need to install the respective GPU backend and a GPU compatible plan will be available via a package extension.\n\nIn case you want to use an alternative NFFT implementation such as NFFT3.jl or FINUFFT.jl we provide wrapper types allowing to use them as AbstractNFFTs implementations. They can be used like this:\n\njulia> using AbstractNFFTs\njulia> include(joinpath(dirname(pathof(AbstractNFFTs)), \"..\", \"..\", \"Wrappers\", \"FINUFFT.jl\"))\njulia> include(joinpath(dirname(pathof(AbstractNFFTs)), \"..\", \"..\", \"Wrappers\", \"NFFT3.jl\"))\n\nThis requires that you first add the package you want to use.\n\nA related package is NonuniformFFTs.jl which provides a pure Julia implementation using KernelAbstractions.jl. It also features an implementation of the AbstractNFFTs.jl interface.","category":"section"},{"location":"#Guide","page":"Home","title":"Guide","text":"The documentation starts with the Mathematical Background that properly defines the NDFT, the NFFT and its directional variants. You might want to skip this part if you are familiar with the notation and concepts of the NFFT. \nThen, an Overview about the usage of the NFFT functions is given in a tutorial style manner.  \nThen, an overview about Accuracy and Performance is given.\nThe section about Tools introduced some high-level functions that build upon the NFFT. For instance NFFT inversion is discussed in that section.\nIn the section about the Abstract Interface for NFFTs we outline how the package is divided into an interface package and implementation packages. This part is useful if you plan to use different NFFT implementations, e.g. one for the CPU and another for the GPU and would like to switch.\nFinally, the documentation contains an API index.","category":"section"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project. You can do so by citing the publication\n\nT. Knopp, M. Boberg and M. Grosser, NFFT.jl: Generic and Fast Julia Implementation of the Nonequidistant  Fast Fourier Transform, 2022 arXiv:2208.00049\n\nA BibTeX file NFFT.bib can be found in the root folder of the Github repository.","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"If you have problems using the software, find bugs or have ideas for improvements please use the issue tracker. For general questions please use the discussions section on Github.","category":"section"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"Tobias Knopp\nRobert Dahl Jacobsen\nMirco Grosser\nJakob Assländer\nMosè Giordano\n\nA complete list of contributors can be found on the Github page.","category":"section"},{"location":"tools/#Tools","page":"Tools","title":"Tools","text":"The packages AbstractNFFT.jl and NFFT.jl are on purpose kept small and focussed. Additional tooling that relates to the NFFT is offloaded into a package NFFTTools.jl. ","category":"section"},{"location":"tools/#Sampling-Density","page":"Tools","title":"Sampling Density","text":"The first tool that NFFTTools.jl offers is the computation of the sampling density. To motivate this let us have a look at the normalized variant of the DFT matrix bmF. bmF is unitary, which means that\n\n bmF^mathsfH bmF = bmI \n\nwhere bmI is the identity matrix. In other words, bmF^mathsfH is the inverse of bmF^mathsfH.\n\nNow let's switch to the NFFT. Have you already wondered why we don't call the adjoint the inverse? Well it's because in general we have\n\n bmA^mathsfH bmA neq bmI \n\nIn fact, the inverse of the NFFT is a much more complicated subject since the linear system bmA bmf = hatbmf can have one, no or many solutions because bmAcan be under- or over-determined.\n\nThe good news is that in most cases, with J approx N and no complete clustering of the sampling nodes, one can find a diagonal weighting matrix bmW = left( w_j right)_j=1^Jsuch that\n\n bmA^mathsfH bmW bmA approx bmI \n\nThe weights w_j can be considered to we quadrature weights that account for the area covered by the node bmk_j. \n\nNFFTTools.jl provides the function sdc that takes an existing plan and calculated suitable density weights:\n\nweights = sdc(p, iters = 10)\n\nThe function implements the method proposed in Pipe & Menon, 1999. Mag Reson Med, 186, 179.","category":"section"},{"location":"tools/#Toeplitz-Kernel","page":"Tools","title":"Toeplitz Kernel","text":"The aforementioned matrix bmA^mathsfH bmW bmA arises when solving linear system of the form\n\nbmA bmf = hatbmf\n\nwhich can be done via the normal equation\n\nbmA^mathsfH bmW bmA bmf = bmA^mathsfH bmW hatbmf\n\nThe normal or Gram matrix bmA^mathsfH bmW bmA has a Toeplitz structure. For multi-dimensional NFFT is is a block Toeplitz matrix with Toeplitz blocks. A Toeplitz matrix (and its block variants) can be embedded into a circulant matrix of twice the size in each dimension. Circulant matrices are known to be diagonalizable by ordinary FFTs. This means we can multiply with bmA^mathsfH bmW bmA by just two FFTs of size 2bmN, which is basically the same amount of FFTs as are required for an NFFT-based calculation of matrix-vector products with bmA^mathsfH bmW bmA. But the important difference is that no convolution step is required for the Toeplitz-based approach. This can often lead to speedups, which are in particular important when using the Gram matrix in iterative solvers  (see Fessler et al., IEEE Trans. Sig. Proc., 53, 9 for the mathematical background).\n\nWith NFFTTools.jl one can calculate the kernel required to exploit the Toeplitz structure with the function calculateToeplitzKernel. Multiplications with the Gram matrix can then be done using the function convolveToeplitzKernel!. The following outlines a complete example for the usage of both functions:\n\nusing NFFT, NFFTTools, FFTW\n\nN = (32, 32)                            # signal size\nÑ = 2 .* N                              # oversampled signal size\n\nk = Float32.(rand(2, 1000) .- 0.5)      # 2D sampling nodes\np = plan_nfft(k, Ñ)                     # 2D NFFT plan\nfftplan = plan_fft(zeros(ComplexF32, Ñ));\n\nλ = Array{ComplexF32}(undef, Ñ)         # pre-allocate Toeplitz kernel \ncalculateToeplitzKernel!(λ, p, k,fftplan)       # calculate Toeplitz kernel \n\ny = randn(ComplexF32, Ñ)\nconvolveToeplitzKernel!(y, λ)           # multiply with Gram matrix\n","category":"section"}]
}
